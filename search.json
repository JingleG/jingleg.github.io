[{"title":"建站首记","path":"/2023/07/30/firstpost/","content":"在折腾了几周之后终于把这个博客上线了，不容易。前期花了不少时间调研各种方案，后面搭的时候也遇到了各种小问题，但总之是搞起来了。 现在已经把基础算法的部分先初步完成了，虽然还有少数部分没写，但留空的都是大概率用不到的东西。有时间会慢慢完善，但是还是会以模板或者描述套路为主，毕竟这部分主要也是写给自己看的，而且要想好好学算法还是找本书要系统的看更有效。在搬运整理的过程中我总怀疑 onedrive 会丢内容，有些我明明之前写过却找不到了，也可能是我忘记保存或者挪来挪去遗失了吧。总之算法的部分肯定会不断完善。 这里也顺便把坑都先挖了，虽然留下了大量空白，但是这些基本都是有草稿的，只是还需要花些时间整理，会陆续更新。","tags":["闲聊"]},{"title":"Hello World","path":"/2023/07/23/hello-world/","content":"起因 作为咸鱼，原本并没有想写blog的，但是刚好有些时间，手上也有些之前上课做的lab，就决定花点时间搞一下玩玩。 计划 先把自己总结的Java算法模板更新下，别问为什么是Java，问就是找工作。 再逐步之前花了大把时间做的lab整理整理，已经完成的6.824和6.830都是非常不错的lab，感觉不记录下有点可惜了。 6.824还被迫读了不少paper，里面有不少内容也值得总结总结。lab部分因为当时上课给的代码不够新，raft的test部分有bug，后来结课的时候去看mit repo发现已经修了，准备重新再写下。另外最后的lab4有不到10%的概率过不了，但是当时完全找不到问题在哪，看看这次能不能来个完美实现。其他的还有6.830，这个比分布式简单不少，也打算抽时间简单写写。 顺便把自学前端的笔记以及总结的后端八股文也搞一下。我自己真的不喜欢这东西，但是懂的都懂。 最后就是手上还有些乱七八糟但非常实用的杂项，虽然没啥技术含量，但也都是自己经验的总结，希望能帮到需要的人。 当然，后面如果遇到有什么值得分享的内容也会放到上面，有机会没准会加个板块更新些生活趣事，但是作为能躺着不坐着的究极懒狗，嗯。 Blog选型 最开始想着自己拿 React 或者 Angular 先搞个简单的前端页面，能看就行，纯当练习前端，后面要是有需要再弄个后台。但转念一想，人生短暂，还是拿别人的用用算了，没必要折磨自己，毕竟还有那么多比造轮子更有意义的事。 既然决定拿来主义，就直接选择了 Hexo 配合 GitHub 静态部署，连服务器都省了，缺点可能是国内可能被墙? Hexo 还有相当多的 theme 和 plugin，主题样式评论基本全都覆盖了。主题这次选了 Staller，主要看中集成了不少插件，免去自己踩坑的时间，同时还有非常不错的wiki文档功能。相比每次都发个单独的文章打上 tag 或者发一个长到离谱的 blog，我更倾向于更新到 wiki 中这种形式。 不过实话实说 Hexo 和 Stellar 的文档实属差了点意思，很多细节仅看文档还是有点难以理解，等有时间再写写是怎么回事。 争取周更","tags":["闲聊"]},{"title":"关于","path":"/about/index.html","content":"关于时间线留言板计划 关于我"},{"title":"计划","path":"/plan/index.html","content":"关于时间线留言板计划 计划 有意向 计划中 进行中 已完成 已弃坑 基础算法 各种值得整理的杂项 6.830 数据库 lab in Java 6.824 分布式 lab 6.824/6.830 paper 6.830 数据库 lab in Go pingcap talent-plan 6.828 operating system cs144 Computer Networking"},{"title":"时间线","path":"/timeline/index.html","content":"关于时间线留言板计划 时间线 2023 年 7 月 30 日Project Blog go online 2023 年 7 月 20 日Project Blog init"},{"title":"写在开始","path":"/wiki/algorithm/index.html","content":"写在开始 给自己总结的常用算法模板，不包含过于复杂的算法&#x2F;数据结构，但足以应付找工作的难度，后续会更新空缺的部分及典型lc例题。面试笔试中相当比例的题基本都可以通过抽象变形直接打板 AC。别问为什么是Java，问就是找工作。此 wiki 不适合 没有接触过算法的初学者阅读。 推荐 这里有一些非常实用的资料，可以参考。 https://oi-wiki.org/OI Wiki https://www.acwing.com/AcWing https://space.bilibili.com/206214bilibili-灵茶山艾府 https://codeforces.com/CodeForces https://www.luogu.com.cn/problem/list洛谷 免责声明 这里所提供的代码模板不保证 bug free，复杂度计算及推导不保证正确，参考使用前请仔细甄别。如有发现错误或任何建议，可以留言讨论。"},{"title":"留言板","path":"/talk/index.html","content":"关于时间线留言板计划 留言"},{"title":"Intro","path":"/wiki/database_lab/index.html","content":"6.5830&#x2F;6.5831: Database Systems http://dsg.csail.mit.edu/6.5830/index.phphttp://dsg.csail.mit.edu/6.5830/index.php 重写的时候发现官网新lab已经用Golang更新了，旧版本的schedule找不到了，这里直接贴上旧版的Git Repo: Set up的部分readme里写的十分详细，有手就行。唯一就是clone下来有自带所有lab的test，测试的时候不太方便。 under construction"},{"title":"Intro","path":"/wiki/back-end/index.html","content":"计划更新下之前学后端相关的笔记总结，包括但不限于 语言 golang python 框架 Spring全家桶 Django 数据类 MySQL MongoDB ES Redis MQ Kafka devops docker kubernetes 八股文"},{"title":"Intro","path":"/wiki/distribute_system_lab/index.html","content":"https://pdos.csail.mit.edu/6.824/https://pdos.csail.mit.edu/6.824/ under construction"},{"title":"Intro","path":"/wiki/env_setup/index.html","content":"常用的配置，虽然一年用不到几次，但是每次需要用的时候都要现查也挺累的 git vscode latex编译 vimrc"},{"title":"Intro","path":"/wiki/front_end/index.html","content":"有关前端的内容 js react angualr"},{"title":"Intro","path":"/wiki/paper/index.html","content":"GFS MapReduce Threads&#x2F;Rpc Raft VM Zookeeper Thor Distributed Transactions FaRM Bayou - Causal Consistency Bitcoin Chord - P2P Borg - cluster management Dynamo - kv storage PUNTS Spark Treadmarks Wormhole"},{"title":"Intro","path":"/wiki/blog/index.html","content":"针对stellar的修改wiki 添加 mermaid&#x2F;mathJax node_modules\\hexo-theme-stellar\\layout\\wiki.ejs1234567891011&lt;%if (page.header == undefined) &#123; page.header = &#x27;auto&#x27;;&#125;%&gt;&lt;% if (page.mermaid == true)&#123; %&gt; &lt;%- partial(&#x27;mermaid&#x27;) %&gt;&lt;% &#125; %&gt;&lt;% if (page.mathjax == true)&#123; %&gt; &lt;%- partial(&#x27;mathjax&#x27;) %&gt;&lt;% &#125; %&gt; 去除代码注释斜体 hexo-theme-stellar\\source\\css\\_common\\highlight.styl12345// 注释.comment color: var(--text-p4)//font-style: italic wiki navi居中navi添加锚点路径增加锚点位置添加relative position \\layout\\_partial\\widgets\\toc.ejs123456789101112131415161718192021222324252627282930function layoutDocTree(pages) &#123; var el = &#x27;&#x27;; pages.forEach((p, i) =&gt; &#123; let isActive = &#x27;&#x27;; if (p.path === page.path) &#123; isActive += &#x27; active&#x27;; el += &#x27;&lt;a class=&quot;anchor&quot; id=&quot;default&quot;&gt;&lt;/a&gt;&#x27; &#125; el += &#x27;&lt;div class=&quot;doc-tree&#x27; + isActive + &#x27;&quot;&gt;&#x27;; if (proj.pages.length &gt; 1) &#123; let href = url_for(p.path); if (p.is_homepage) &#123; href += &#x27;#start&#x27; &#125;else&#123; href += &#x27;#default&#x27; &#125; el += &#x27;&lt;a class=&quot;doc-tree-link&#x27; + isActive + &#x27;&quot; href=&quot;&#x27; + href + &#x27;&quot;&gt;&#x27;; el += &#x27;&lt;span class=&quot;toc-text&quot;&gt;&#x27; + (p.title || p.seo_title) + &#x27;&lt;/span&gt;&#x27;; el += &#x27;&lt;/a&gt;&#x27;; &#125; if (p.path === page.path) &#123; el += layoutToc(); &#125; el += &#x27;&lt;/div&gt;&#x27;; &#125;); return el;&#125; \\source\\css\\_layout\\widgets\\toc_wiki.styl12345a.anchor display: block; position: relative; top: -50VH; visibility: hidden; 增加sidebar margin 1234567.l_left[layout=wiki] padding-bottom: 0 height: 100vh @media screen and (max-width: $device-mobile-max) height: 100vh .widgets &gt;:last-child margin-bottom: 25vh"},{"title":"Binary Search","path":"/wiki/algorithm/basicAlgo/binary_search.html","content":"二分是最常见的经典算法，两个模板，搜索左边界和搜索右边界。使用条件：搜索域具有二段性，即存在可以二分的某种性质。对于搜索域上的分界点，该分界点所有左侧元素符合这一性质而所有的右侧元素不符合。 左边界符合要求的第一个位置，即左边界 (left bound) 12345678910int binarySearchLeft(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; // int mid = left + right &gt;&gt; 1; int mid = left + (right - left) / 2; if (check(mid)) right = mid; else left = mid + 1; &#125; return nums[left];// may need to check nums[left]&#125; 右边界符合要求的最后一个位置，即右边界 (right bound) 123456789int binarySearchRight(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int mid = left + (right - left + 1) / 2; if (check(mid)) left = mid; else right = mid - 1; &#125; return nums[left];// may need to check nums[left]&#125; 经典应用求xxx的最大值&#x2F;最小值，二分枚举可能的最值，遍历数据检查是否可行 123456789101112int getMax()&#123; int min, max; while(min &lt; max)&#123; int mid = min + max &gt;&gt; 1; if(check(mid)) min = mid + 1; else max = mid; &#125; return min;&#125;boolean check(int mid)&#123; // check mid is valid&#125;"},{"title":"KMP","path":"/wiki/algorithm/basicAlgo/kmp.html","content":"$O(n)$ 匹配字符串，也常用于求两字符串的前后缀匹配的长度。KMP除了硬背，也可以考虑可以使用Rolling hash曲线救国，一般不做强制要求。 next数组： 对于p， next[i] = j 等同于 p[1, j] = p[i-j+1, i]。 即以i为结尾，长度为j的后缀与下标为1开始的部分匹配。 最长前缀(prefix) 与 最长后缀 (suffix) 的相同长度 12345678910111213141516171819202122int kmp(String str, String pattern) &#123; if (pattern.length() == 0) &#123; return 0; &#125; int[] next = new int[pattern.length() + 1]; char[] s = (&#x27; &#x27; + str).toCharArray(); char[] p = (&#x27; &#x27; + pattern).toCharArray(); for (int i = 2, j = 0; i &lt; next.length; i++) &#123; while (j != 0 &amp;&amp; p[j + 1] != p[i]) j = next[j]; if (p[j + 1] == p[i]) j++; next[i] = j; &#125; for (int i = 1, j = 0; i &lt; s.length; i++) &#123; while (j != 0 &amp;&amp; p[j + 1] != s[i]) j = next[j]; if (p[j + 1] == s[i]) j++; if (j == p.length - 1) &#123; // j=next[j]; return i - pattern.length(); &#125; &#125; return -1;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int kmp(String str, String pattern) &#123; if (pattern.length() == 0) &#123; return 0; &#125; // 字符串都从1开始 // 需要一个n加1长度的next数组，其中0和1均为0 int[] next = new int[pattern.length() + 1]; char[] s = (&#x27; &#x27; + str).toCharArray(); char[] p = (&#x27; &#x27; + pattern).toCharArray(); // example &quot;ababcab&quot;, comparing i and j+1 each time // | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | // | | | | | | | | | // | | a | b | a | b | c | a | b | =&gt; pattern // | j | | i | | | | | | // | 0 | 0 | 0 | | | | | | =&gt; next // next step, j+1 match i,let j++ and next[i]=j // | | a | b | a | b | c | a | b | =&gt; pattern // | j--&gt;j | | i | | | | | // | 0 | 0 | 0 | 1 | | | | | =&gt; next // if j+1 != i, rewind j to next[j] // | | a | b | a | b | c | a | b | =&gt; pattern // | | | | j |j+1| i | | | // | 0 | 0 | 0 | 1 | 2 | 0 | | | =&gt; next // | | j&lt;-----j+1| | i | | | //\tj -&gt; 1 and comparing j+1&amp;i or j==0 // after rewind // | | a | b | a | b | c | a | b | =&gt; pattern // | | j | | | | | i | | // | 0 | 0 | 0 | 1 | 2 | 0 | 1 | | =&gt; next for (int i = 2, j = 0; i &lt; next.length; i++) &#123; while (j != 0 &amp;&amp; p[j + 1] != p[i]) &#123; // j不是0，且j+1的字符能够匹配，就停止回溯 // 否则，j回溯到next[j],检查下一字符是否匹配 j = next[j]; &#125; if (p[j + 1] == p[i]) &#123; //如果因为匹配停止，j前进1 j++; &#125; // 将next[j]置为j(如果因为回溯到头停止则为0) next[i] = j; &#125; // comparing j+1 and i // | 0 | 1 | 2 | 3 | 4 | 5 | // |“ ”| h | a | O | a | a | =&gt; str // | | i | | | | | // |“ ”| a | a | =&gt; pattern // | 0 | 0 | 1 |\t=&gt; next // | j | | | // until i and j+1 not match, rewind // |“ ”| h | a | a | c | a | =&gt; str // | | | | | i | | // |“ ”| a | a | b |\t=&gt; pattern // | 0 | 0 | 1 | 0 |\t=&gt; next // | | j&lt;--j |j+1|\trewind j to 1(next[j]) // then j+1 still not match i, rewind to 0 for (int i = 1, j = 0; i &lt; s.length; i++) &#123; while (j != 0 &amp;&amp; p[j + 1] != s[i]) &#123; // 只有当j=0或者当前j+1字符匹配，停止 j = next[j]; &#125; if (p[j + 1] == s[i]) &#123; // 如果匹配，则将j++，否则j会回到0位置 j++; &#125; if (j == p.length - 1) &#123; // find match // j = next[j]; if keep searching return i - pattern.length(); &#125; &#125; return -1;&#125;"},{"title":"Bit Operation","path":"/wiki/algorithm/basicAlgo/bit_operation.html","content":"主要用于状压DP 清零 12// 将第11-20位的值清零n &amp;= 0xFFF003FF; 获取 12t = (x&gt;&gt;k) &amp; 1 // 第k位t = (n &amp; 0xFFFFF)&gt;&gt;10; //获取第11-20位的值 lowbit(x) 12345678// 返回最低位1所代表的数return x &amp; -x; // 统计1的个数while(x)&#123; x -= lowbit(x);//每次减去lowbit,直到为0; res++;&#125; 枚举二进制的子集 123456// st=101// j=101, 100, 001, 000int st; //当前的状态for(int j = st; j &gt; 0; j = (j-1)&amp;st)&#123; j; // j是st的子集&#125; 二进制子集求和 12345678// 已知状态 st 的方案数 为 其所有子状态的和// 如状态 11 由 其子状态 01, 10, 00 组成for(int i = 0; i &lt; len; i++)&#123;\t// 枚举最高位 for(int j = 0, bit = 1&lt;&lt;i; j &lt; bit; j++)&#123; //去除最高位的所有情况+最高位，bit即为最高位 sum[bit|j] = sum[j] + nums[i]; &#125;&#125;"},{"title":"Sort","path":"/wiki/algorithm/basicAlgo/sort.html","content":"排序也是经典算法，虽然绝大多数时候不需要手写，但不排除出现的可能。常用排序算法： 插入 快排，及其变形快速选择 归并 三色排序 JDK 中 sort() 实现 长度小于MAX_INSERTION_SORT_SIZE，插入排序 根据 元素结构&#x2F;数量&#x2F;是否重复 使用 快排&#x2F;双轴快排&#x2F;归并&#x2F;堆排&#x2F;计数 Insert Sort Time: $ \\mathcal{O}( n^2 ) $ space: $ \\mathcal{O}( 1 ) $ 稳定，数据有序时效率高，best: $ \\mathcal{O} (n) $ 1234567891011int[] sortArray(int[] nums) &#123; for (int i = 1; i &lt; nums.length; i++) &#123; int k = nums[i]; int j = i - 1; for (; j &gt;= 0 &amp;&amp; nums[j] &gt; k; j--) &#123; nums[j + 1] = nums[j]; &#125; nums[j + 1] = k; &#125; return nums;&#125; Quick Sort Time: average: $\\mathcal{O}( n\\log{n} )$, worst: $ \\mathcal{O} ( n^2 ) $ space: $ \\mathcal{O}( \\log{n} ) $ 优化 三数取中，避免极端数据 序列较短时使用插入排序 将与分界元素相等的元素聚集在分界元素周围， 处理大量相同元素的序列 三路（双轴）快排 3-way Radix（DualPivot） Quicksort 结合荷兰国旗问题，随机选取分界点 mid 后，将数列划分为 小于mid，等于mid，大于mid 1234567891011121314151617181920212223242526272829303132void quickSort(int[] nums, int left, int right) &#123; if (left &gt;= right) return; int i = left - 1, j = right + 1;//from l-1, r+1 //mid = nums[random.nextInt(right - left) + left] int mid = nums[left + right &gt;&gt; 1]; while (i &lt; j) &#123; //or while(nums[++i]&lt;mid); do i++; while (nums[i] &lt; mid); do j--; while (nums[j] &gt; mid); if (i &lt; j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125; &#125; quickSort(nums, left, j); // must j quickSort(nums, j + 1, right);&#125;void sort_3_way(int[] nums, int l, int r) &#123; if (l &gt;= r) return; swap(nums, l, l + r &gt;&gt; 1);// choose mid int mid = nums[l]; int i = l, j = r, k = l + 1; while (k &lt;= j) &#123; if (nums[k] &lt; mid) swap(nums, i++, k++); else if (nums[k] &gt; mid) swap(nums, j--, k); else k++; &#125; sort(nums, l, i - 1); sort(nums, j + 1, r);&#125; quick select 快速选择选择top k元素平均 $ \\mathcal{O} (n) $ 123456789101112131415161718192021int select(int[] nums, int left, int right, int k) &#123; if (left &gt;= right) return nums[k]; int i = left - 1, j = right + 1; // right position is not available int index = random.nextInt(right - left) + left; int mid = nums[index]; while (i &lt; j) &#123; // k biggest/k smallest: nums[i] &lt; mid do i++; while (nums[i] &gt; mid); do j--; while (nums[j] &lt; mid); if (i &lt; j) &#123; int temp = nums[j]; nums[j] = nums[i]; nums[i] = temp; &#125; &#125; // j is the pivot i after the sort, value is mid; // check k with j and then recurse one side. if (k &lt;= j) return select(nums, left, j, k); else return select(nums, j + 1, right, k);&#125; 优化: BFPRT 最坏 $ \\mathcal{O} (n) $ 1// todo Merge Sort Time: $\\mathcal{O}( n\\log{n} )$ space: $ \\mathcal{O}( n ) $ 123456789101112131415public void mergeSort(int[] nums, int left, int right) &#123; if (left &gt;= right) return; int mid = left + (right - left) / 2; mergeSort(nums, left, mid); mergeSort(nums, mid + 1, right); int k = 0, i = left, j = mid + 1; int[] temp = new int[right - left + 1]; while (i &lt;= mid &amp;&amp; j &lt;= right) if (nums[i] &lt; nums[j]) temp[k++] = nums[i++]; else temp[k++] = nums[j++]; while (i &lt;= mid) temp[k++] = nums[i++]; while (j &lt;= right) temp[k++] = nums[j++]; for (i = left, j = 0; i &lt;= right; i++, j++) nums[i] = temp[j];&#125; Dutch flag 三色排序12345678void sortColor(int[] nums)&#123; // [0, p0-1]全为0，[p0, p1-1]全为1，[p2+1, len]全为2 for (int p0 = 0, p1 = 0, p2 = nums.length - 1; p1 &lt;= p2; ) &#123; if (nums[p1] == 0) swap(nums, p0++, p1++); else if (nums[p1] == 1) p1++; else swap(nums, p1, p2--);// p1不移动，p2指向的数字不保证为1 &#125;&#125;"},{"title":"Rolling Hash","path":"/wiki/algorithm/basicAlgo/rolling_hash.html","content":"字符串哈希，将字符串映射为 p 进制数从而满足 字符串 在 HashMap 作为 key 的 $O(1)$ 访问 不能将字符映射为0（a-&gt;0, aa-&gt;0) 冲突：假定不存在冲突 p取131或13331，q取$2^{64}$ (long溢出) 12345678910hash(DEF) = hash(ABCDEF) - hash(ABC) x P^3 1 2 3 4 5 6 A B C D E F 1xP^5 + 2xP^4 + 3xP^3 + 4xP^2 + 5xP^1 + 6xP^0 D E F 4xP^2 + 5xP^1 + 6xP^0 L R A B C 1xP^2 + 2xP^1 + 3xP^0 123456789101112131415161718int P = 13331; // 使用P进制，mod使用long自带溢出2^64 String str; // 原始stringString s = &quot; &quot; + str; // 对齐字符串到1位置,h[0]=0int len = s.length();long[] h = new long[len]; // hashlong[] p = new long[len]; // p^np[0] = 1;for(int i = 1;i &lt; l;i++)&#123; // 计算h值 p[i] = p[i - 1] * P; h[i] = h[i - 1] * P + s.charAt(i);&#125;// a b c d// l r &quot;bc&quot; left=2, right=3// 求 hash 对应 s[left ~ right] 即原字符串str的left-1到right-1long get(int left,int right)&#123; return h[right] - h[left - 1] * p[right - left + 1];&#125;"},{"title":"Binary Indexed Tree","path":"/wiki/algorithm/dataStructure/binary_indexed_tree.html","content":"树状数组，是一种支持 单点修改 和 区间查询 数据结构，单次操作 $\\log n$。具体原理这里就不作赘述了，想了解细节请 TP，保证看到吐血。这里放一张简单原理图，核心思想为前缀拆分。 单点修改 + 区间查询1234567891011121314151617181920212223242526int n = 1001; //需要分配等同于 x+1 大小的空间，下标1开始，如果x是[0,1000]int[] tr = new int[n+1]; //tr 需要分配n+1的空间//lowbit(x)int lowbit(int x)&#123; return x &amp; -x;&#125;//如果对a[x]进行修改, void add(int x, int c)&#123; // x &gt; 1 for(int i = x ; i &lt;= n ; i += lowbit(i)) tr[i] += c;&#125;//查询a[1~x]的和int sum(int x)&#123; int res = 0; for(int i = x ; i &gt; 0; i -= lowbit(i)) res += tr[i]; return res;&#125;int query(int l, int r)&#123; return sum(r) - sum(l - 1);&#125;//快速构建 o(n), 使用前缀和s[x] 快速计算 c[x] = a[x-lowbit(x)+1 ~ x] c[x]= s[x] - s[x-lowbit(x)]; 区间修改 + 单点查询等同于差分数组，前缀的逆运算。 查询：设原数组为 $a[i]$ , 设数组 $ d[i]&#x3D;a[i]−a[i−1](a[0]&#x3D;0)$， 则 $a[i]&#x3D;\\sum_{j&#x3D;1}^i d[j] $, 可以通过求 $d[i]$ 的前缀和查询 修改：当给区间 $[l, r]$ 加 $x$ 时，$ a[l]$ 与前一个元素 $a[l-1]$ 的差增加了 $x$，$a[r+1]$ 与 $a[r]$ 的差减少了 $x$，根据 $d[i]$ 数组的定义，只需给 $d[l]$ 加上 $x$, 给 $d[r+1]$ 减去 $x$ 即可。 1234567891011121314void add(int x, int c)&#123; for(int i = x ; i &lt;= n ; i += lowbit(i)) tr[i] += c;&#125;// add c to [l, r]void range_update(int l,int r,int c)&#123; add(l, c); add(r + 1, -c);&#125;// query xint query(int x)&#123; int res = 0; for(int i = x; i &gt; 0; i -= lowbit(i)) res += tr[i]; return res;&#125; 二维单点修改 + 区间查询 1234567891011121314151617181920212223242526272829303132333435363738int[][] t;int[][] a;int l,w;public NumMatrix(int[][] matrix) &#123; l=matrix.length; w=matrix[0].length; a=new int[l][w]; t=new int[l+1][w+1]; for(int i=0;i&lt;l;i++) for(int j=0;j&lt;w;j++) update(i,j,matrix[i][j]);&#125;int lowbit(int i)&#123; return i&amp;-i;&#125;void update(int row, int col, int val) &#123; int dif=val-a[row][col]; a[row][col]=val; row++; col++; for(int i=row;i&lt;=l;i+=lowbit(i)) for(int j=col;j&lt;=w;j+=lowbit(j)) t[i][j]+=dif;&#125;int sum(int x,int y)&#123; int res=0; for(int i=x;i&gt;0;i-=lowbit(i)) for(int j=y;j&gt;0;j-=lowbit(j)) res+=t[i][j]; return res;&#125;int range_sum(int row1, int col1, int row2, int col2) &#123; return sum(row2+1,col2+1)+sum(row1,col1)-sum(row1,col2+1)-sum(row2+1,col1);&#125; 其他此部分不推荐使用，建议直接使用 线段树 替代区间修改 + 区间求和基于问题2的“差分”思路，考虑一下如何在问题2构建的树状数组中求前缀和：位置p的前缀和 $&#x3D;\\sum_{i&#x3D;1}^{p} a[i]&#x3D;\\sum_{i&#x3D;1}^{p} \\sum_{j&#x3D;1}^{i} d[j]$在 $\\sum_{i&#x3D;1}^{p} \\sum_{j&#x3D;1}^{i} d[j]$中， $d[1]$ 被用了 $p$ 次， $d[2]$ 被用了 $p-1$ 次 …则 位置p的前缀和 $ \\sum_{i&#x3D;1}^{p} \\sum_{j&#x3D;1}^{i} d[j]&#x3D;\\sum_{i&#x3D;1}^{p} d[i] *(p-i+1)&#x3D;(p+1) * \\sum_{i&#x3D;1}^{p} d[i]-\\sum_{i&#x3D;1}^{p} d[i] * i$维护两个前缀和数组一个数组是 $sum1[i]&#x3D;d[i]$另一个数组是 $sum2[i]&#x3D;d[i]∗i$查询：位置p的前缀和即：$(p + 1) * sum1$数组中p的前缀和 - sum2数组中p的前缀和。区间[l, r]的和即：位置$r$的前缀和 - 位置$l$的前缀和。修改：对于sum1数组的修改与差分相同。对于sum2数组的修改，给 sum2[l] 加上 $l * x$，给 sum2[r + 1] 减去 $(r + 1) * x$。1234567891011121314151617181920void add(long p, long x)&#123; for(int i = p; i &lt;= n; i += i &amp; -i) sum1[i] += x, sum2[i] += x * p;&#125;void range_add(long l, long r, long x)&#123; add(l, x); add(r + 1, -x);&#125;long query(long p)&#123; ll res = 0; for(int i = p; i &gt; 0; i -= i &amp; -i) res += (p + 1) * sum1[i] - sum2[i]; return res;&#125;long range_query(long l, long r)&#123; return query(r) - query(l - 1);&#125; 推荐阅读https://www.cnblogs.com/RabbitHu/p/BIT.html胡小兔的OI博客"},{"title":"Binary Tree","path":"/wiki/algorithm/dataStructure/binary_tree.html","content":"二叉树遍历 递归（略过） 迭代 Morris pre-order&#x2F;in-order1234567891011Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();while(root != null || !stack.isEmpty())&#123; while(root != null)&#123; // preorder stack.push(root); root = root.left; &#125; root = stack.pop(); // inorder root = root.right;&#125; post-order1234567891011121314151617Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();TreeNode prev = null;while (root != null || !stack.isEmpty()) &#123; while (root != null) &#123; stack.push(root); root = root.left; &#125; root = stack.pop(); if (root.right == null || root.right == prev) &#123; // visit node prev = root; root = null; &#125; else &#123; stack.push(root); root = root.right; &#125;&#125; level-order123456789101112131415Deque&lt;TreeNode&gt; queue = new ArrayDeque&lt;&gt;();queue.addLast(root);while(!queue.isEmpty())&#123; int level = queue.size(); List&lt;Integer&gt; temp = new ArrayList&lt;&gt;(); for(int i = 0;i &lt; level; i++)&#123; TreeNode node = queue.pollFirst(); // visit node temp.add(node.val); if(node.left != null) queue.addLast(node.left); if(node.right != null) queue.addLast(node.right); &#125; result.add(temp);&#125;return result; Morris使用常数空间遍历二叉树 pre&#x2F;inorder从根节点开始遍历，直至当前节点为空为止： 如果当前节点没有左儿子，则打印当前节点的值，然后进入右子树; 如果当前节点有左儿子，则找当前节点的前驱。 如果前驱节点的右儿子为空，说明左子树没遍历过，则进入左子树遍历，并将前驱节点的右儿子置成当前节点，方便回溯； 如果前驱节点的右儿子为当前节点，说明左子树已被遍历过，则将前驱节点的右儿子恢复为空，然后打印当前节点的值，然后进入右子树继续遍历； 1234567891011121314151617181920212223242526272829List&lt;Integer&gt; res=new ArrayList&lt;&gt;();TreeNode cur=root,pre=null; while(cur!=null)&#123; if(cur.left==null)&#123; // 当前左子树为空，进入右子树 visit(cur); // 访问cur (inorder/preorder) cur=cur.right; &#125;else&#123; TreeNode p=cur.left; // 当前左子树不为空，令p进入左子树，不断向右找到最后一个前继节点 while(p.right!=null&amp;&amp;p.right!=cur)&#123; // 即 p.right 为空 或 p.right 为cur p=p.right; &#125; if(p.right==null)&#123; // 为空则代表左子树未被访问，连接该前继节点p.right=cur p.right=cur; visit(cur); // 访问cur (preorder) cur=cur.left; // 进入左子树遍历 &#125;else&#123; // p.right=cur则代表该左子树完成遍历，断开p.right p.right=null; visit(cur);// 访问该节点 (inorder) cur=cur.right;// 进入右子树 &#125; &#125;&#125;return res; postorder 设置一个虚拟头节点，虚拟头节点的左孩子指向根节点。当前节点从虚拟头节点开始 如果当前节点的左孩子为空，则将其右孩子作为当前节点。 如果当前节点的左孩子不为空，在当前节点的左子树中找到当前节点的前继 如果前继的右孩子为空，搭桥，当前节点的左孩子成为新节点 如果前继的右孩子为当前节点，拆桥。逆序输出从当前节点的左孩子到前继节点路径上的节点。当前节点的右孩子成为新节点。(先拆桥，反转链表，输出，反转复原) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; TreeNode dummy=new TreeNode(-1,root,null); TreeNode cur=dummy; List&lt;Integer&gt; res=new ArrayList&lt;&gt;(); while(cur!=null)&#123; if(cur.left==null)&#123; // 左子树为空，访问右子树 cur=cur.right; &#125;else&#123; // 左子树不为空，寻找前继节点 TreeNode p=cur.left; while(p.right!=null&amp;&amp;p.right!=cur)&#123; p=p.right; &#125; if(p.right==null)&#123; // 前继节点为空，左子树未遍历，搭桥，访问左子树 p.right=cur; cur=cur.left; &#125;else&#123; // 左子树已经访问，逆序输出cur.left -&gt; p p.right=null; output(cur.left,p,res); cur=cur.right; &#125; &#125; &#125; return res;&#125;void output(TreeNode start,TreeNode end,List&lt;Integer&gt; res)&#123; // 反转，输出，恢复 reverse(start,end); TreeNode cur=end; while(cur!=null)&#123; res.add(cur.val); cur=cur.right; &#125; reverse(end,start);&#125;void reverse(TreeNode start,TreeNode end)&#123; // 反转链表 TreeNode pre=start,cur=start.right; while(cur!=null)&#123; TreeNode temp=cur.right; cur.right=pre; pre=cur; cur=temp; &#125; start.right=null;&#125;"},{"title":"Hash Table","path":"/wiki/algorithm/dataStructure/hash_table.html","content":"开放寻址 Open addressing12345678910111213141516171819202122232425262728293031int[] h = new int[N];int de = -2; // 标记被删除int nu = -1; // 标记为空void init() &#123; Arrays.fill(h, nu);&#125;int find(int x) &#123; int k = x % N; while (h[k] != nu &amp;&amp; h[k] != X) &#123; k++; if (k == N) k = 0; &#125; return k;&#125;void insert(int x) &#123; int k = find(x); h[k] = x;&#125;boolean contains(int x) &#123; int k = find(x); return h[k] == x;&#125;void remove(int x) &#123; int k = find(x); if (h[k] == x) h[k] = de;&#125; 链表 Separate chaining数组模拟 Array simulation123456789101112131415161718192021222324252627282930313233343536373839int N = (int) 1e5 + 3;// 头插int[] h = new int[N]; // 对应槽i的第一个元素位置int[] e = new int[N]; // 对应位置i元素的值int[] ne = new int[N]; // 对应位置i元素的下一个元素位置int idx = 0; // 当前下标void init() &#123; Arrays.fill(h, -1);&#125;int find(int x) &#123; // 返回元素位置 int k = x % N; for (int i = h[k]; i != -1; i = ne[i]) &#123; if (e[i] == x) return i; &#125; return -1;&#125;void insert(int x) &#123; if (find(x) == -1) &#123; int k = x % N; e[idx] = x; // idx 位置为元素x ne[idx] = h[k]; // 元素x的下一个元素为k槽的头元素 h[k] = idx++;\t// 更新k槽头元素为x &#125;&#125;void remove(int x) &#123; int t = find(x); if (t != -1) &#123; e[t] = -1; &#125;&#125;boolean contains(int x) &#123; int t = find(x); return t != -1;&#125; 链表节点 LinkedList123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263class MyHashMap&lt;K, V&gt; &#123; class ListNode&lt;K, V&gt; &#123; K key; V value; ListNode next; ListNode(K k, V v) &#123; this.key = k; this.value = v; &#125; &#125; ListNode&lt;K, V&gt;[] head; int N = 10; MyHashMap() &#123; head = new ListNode[N]; &#125; V get(K key) &#123; int hash = key.hashCode() % N; ListNode&lt;K, V&gt; ptr = head[hash]; while (ptr != null) &#123; if (ptr.key.equals(key)) &#123; return ptr.value; &#125; ptr = ptr.next; &#125; return null; &#125; void put(K key, V value) &#123; int hash = key.hashCode() % N; ListNode&lt;K, V&gt; ptr = head[hash]; while (ptr != null) &#123; if (ptr.key.equals(key)) &#123; ptr.value = value; return; &#125; ptr = ptr.next; &#125; ListNode&lt;K, V&gt; t = new ListNode&lt;&gt;(key, value); t.next = head[hash]; head[hash] = t; &#125; void remove(K key) &#123; int hash = key.hashCode() % N; ListNode&lt;K, V&gt; dummy = new ListNode(null, null); dummy.next = head[hash]; ListNode&lt;K, V&gt; pre = dummy, cur = head[hash]; while (cur != null) &#123; if (cur.key.equals(key)) &#123; pre.next = cur.next; break; &#125; pre = cur; cur = cur.next; &#125; head[hash] = dummy.next; &#125;&#125;"},{"title":"Heap","path":"/wiki/algorithm/dataStructure/heap.html","content":"数组模拟数组存储：下标1开始，根节点x，左儿子为 2*x，右儿子为2*x+1 插入一个数 heap[++size] = x; up(size); 求集合中最小值 return heap[1]; 删除最小值 heap[1] = heap[size--]; down(1); 删除任意一个元素 heap[k] = heap[size--]; down(k); up(k); 修改任意元素 heap[k] = x; down(k); up(k); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// 小根堆int[] heap=new int[1000];int size=0;void build(int[] nums)&#123;// 快速建堆O(n) // 所有元素放入堆中 for(int t:nums) heap[size++]=t; // 将除去叶节点外所有节点down // 1*n/4 + 2*n/8 + 3*n/16 + (倒数第i层)*(该层节点数)+... for(int i=size/2;i&gt;0;i--) down(i);&#125;void down(int u)&#123; int t = u; if (u * 2 &lt;= size &amp;&amp; heap[u * 2] &lt; heap[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; heap[u * 2 + 1] &lt; heap[t]) t = u * 2 + 1; // t为3个点中最小的点 if (u != t) &#123; //如果根节点不是最小，swap swap(t, u); //递归处理交换后的节点 down(t); &#125;&#125;void up(int u)&#123; while (u/2 != 0 &amp;&amp; heap[u / 2] &gt; heap[u]) &#123; //如果不是小的，递归上浮 swap(u / 2, u); u /= 2; &#125;&#125;void add(int n)&#123; heap[++size]=n; up(size);&#125;int poll()&#123; int t=heap[1]; heap[1]=heap[size--]; down(1);&#125;int size()&#123; return size;&#125;// heapsort为build后依次poll();void swap(int i,int j)&#123; int temp=heap[i]; heap[i]=heap[j]; heap[j]=temp;&#125; 修改&#x2F;删除任意元素1234567891011121314151617181920212223242526272829303132333435363738394041424344454647Map&lt;Integer,Integer&gt; map;// 维护元素 key-&gt;heap 位置的映射void modify(int n)&#123; int idx=map.get(n); heap[idx] = n; down(k); up(k);&#125;void delete(int n)&#123; int idx=map.get(n); heap[idx] = heap[size--]; down(k); up(k)&#125;void down(int u)&#123; int t = u; if (u * 2 &lt;= size &amp;&amp; heap[u * 2] &lt; heap[t]) t = u * 2; if (u * 2 + 1 &lt;= size &amp;&amp; heap[u * 2 + 1] &lt; heap[t]) t = u * 2 + 1; // t为3个点中最小的点 if (u != t) &#123;//如果根节点不是最小，swap swap(t, u); // 维护映射 int num1=heap[t],num2=heap[u]; map.put(num1,u); map.put(num2,p); //递归处理交换后的节点 down(t); &#125;&#125;void up(int u)&#123; while (u/2 != 0 &amp;&amp; heap[u / 2] &gt; heap[u]) &#123; //如果不是小的，递归上浮 swap(u / 2, u); // 维护映射 int num1=heap[u],num2=heap[u/2]; map.put(num1,u/2); map.put(num2,u); u /= 2; &#125;&#125; 堆排序123456// 先建堆，再不断poll() 即可void sort()&#123; System.out.println(heap[0]); heap[0] = heap[size--]; down(0);&#125;"},{"title":"Linked List","path":"/wiki/algorithm/dataStructure/linked_list.html","content":"Reverse翻转链表 1234567891011ListNode reverseList(ListNode head) &#123; ListNode pre = null, cur = head; while(cur != null &amp;&amp; checkEnd())&#123; // check the end ListNode temp = cur.next; cur.next = pre; pre = cur; cur = temp; &#125; head.next = cur; // put the head node to the end return pre;&#125; Cycle链表找环 1234567891011121314151617181920212223242526272829 |---b---|----a---X * |--c----|// 快指针 f 每次移动2, 慢指针s 每次移动1// 可以证明 s 必然在 未走完一圈 的状态下与 f 相遇// f 每次追赶 s 1节点，故f不可能跨过s, 如果当前跨过则前一个位置已经相遇 // 快慢指针于* 相遇, 环入口为 X, a/b/c代表三段的长度 // 假设快指针走了n圈，则快指针走过 a + n(b+c) + b// a + (n + 1)b + nc = 2(a + b) ⟹ a = c + (n−1)*(b+c)//从相遇点到入环点的距离加上n−1圈的环长，恰好等于从链表头部到入环点的距离ListNode detectCycle(ListNode head) &#123; ListNode f = head, s = head; while (f != null &amp;&amp; f.next != null) &#123; f = f.next.next; s = s.next; if (f == s) &#123; f = head; while (f != s) &#123; f = f.next; s = s.next; &#125; return f; &#125; &#125; return null;&#125;"},{"title":"Persistent data structure","path":"/wiki/algorithm/dataStructure/persistent_data_structure.html","content":"持久化 Trie 持久化 线段树（主席树） 待填坑 ···"},{"title":"Prefix Sum / Diff Array","path":"/wiki/algorithm/dataStructure/presum.html","content":"前缀和查询$ \\mathcal{O}( 1 ) $， 修改$ \\mathcal{O}( n ) $，多次 查询区间和 12345int[] pre = new int[len + 1]; // 下标1为0for(int i = 0; i &lt; len; i++)&#123; pre[i + 1] = pre[i] + a[i];&#125;Sum(l, r) = pre[r] - pre[l - 1]; 二维前缀和 对于上图的绿色矩形的值，即为 黑色 - 蓝色 + 红色。由于前缀和数组中，pre数组与原nums数组坐标差一，需要对齐。下面的代码中 sum(x1,y1,x2,y2) 对应0开始的原始 nums 矩阵的坐标。 12345678910// index from 0int[][] nums = new int[n][m];int[][] pre = new int[n+1][m+1];for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; pre[i][j]=pre[i-1][j]+pre[i][j-1]-pre[i-1][j-1]+nums[i-1][j-1]; &#125;&#125;// index from 0, same as numssum(x1,y1,x2,y2)=pre[x2+1][y2+1]-pre[x1][y2+1]-pre[x2][y1+1]+pre[x1][y1]; 前缀和的前缀和123456789101112131415161718192021222324252627282930313233例：对于数组[1,5,4,3,6,7,8,2]，求[5,4,3,6,7,8]范围内所有包含3的子数组的和。[3] -----------&gt; s[3] - s[2][3,6] ---------&gt; s[4] - s[2][3,6,7] -------&gt; s[5] - s[2][3,6,7,8] -----&gt; s[6] - s[2][4,3] ---------&gt; s[3] - s[1][4,3,6] -------&gt; s[4] - s[1][4,3,6,7] -----&gt; s[5] - s[1][4,3,6,7,8] ---&gt; s[6] - s[1][5,4,3] -------&gt; s[3] - s[0][5,4,3,6] -----&gt; s[4] - s[0][5,4,3,6,7] ---&gt; s[5] - s[0][5,4,3,6,7,8] -&gt; s[6] - s[0]记s[i]表示[0,i]的前缀和，那么上面所有子数组的和就是：a * (s[3] + s[4] + s[5] + s[6]) - b * (s[0] + s[1] + s[2])其中 a = 3 = i - left + 1，b = 4 = right - i + 1而(s[3] + s[4] + s[5] + s[6])、(s[0] + s[1] + s[2])就是对s[i]数组求和的过程, (s[3] + s[4] + s[5] + s[6]) = ss[6] - ss[2] = ss[right] - ss[i - 1]for(int i=0;i&lt;l;i++)&#123;\tpre[i+1]=pre[i]+st[i]; //错位1&#125;for(int i=0;i&lt;l;i++)&#123; ppre[i+2]=ppre[i+1]+pre[i+1]; //错位2&#125;// [1, 5,4,3,6,7,8, 2]//其中left为左移1位置（index=0）right为右移1位置(index=7)，单调栈int ll=left[i]+2,mm=i+2,rr=right[i]+2;// +2 对应两次前缀和的右移long a=(mm-ll)*(ppre[rr-1]-ppre[mm-1]);long b=(rr-mm)*(ppre[mm-1]-ppre[ll-1]);long temp=a-b; 差分给定区间[l, r]，对区间内所有数加上值 v。 区间修改$ \\mathcal{O}( 1 ) $，单次查询$ \\mathcal{O}( n ) $ 123456789101112131415161718//下标均从0开始int[] nums = new int[n];int[] dif = new int[n];dif[0] = nums[0];for (int i = 1; i &lt; n; i++) &#123; dif[i] = nums[i] - nums[i - 1];&#125;// 给 [l,r] 加上vdif[l] += v;dif[r + 1] -= v;// nums[i] = sum( dif[0] ~ dif[i] )// 更新numsfor (int i = 0, sum = 0; i &lt; n; i++) &#123; sum += dif[i]; nums[i] = sum;&#125; 二维差分 对(x1,y1)加1，则相当于对所有右下角的矩形和均加1。需要对蓝色区域减1，同时对红色区域加1。 1234567891011121314151617181920212223242526272829303132// 构造修改, 对于一个位于（x1,y1) 的单独元素，视为对区间[x1,y1],[x1,y1]进行插入int[][] nums=new int[n][m];int[][] dif=new int[n+1][m+1];for(int i=0;i&lt;n;i++)&#123; for(int j=0;j&lt;m;j++)&#123; dif[i][j]+=nums[i][j]; dif[i+1][j]-=nums[i][j]; dif[i][j+1]-=nums[i][j]; dif[i+1][j+1]+=nums[i][j]; &#125;&#125;// nums[i][j] = sum(dif[0~i][0~j])// 查询单个元素，直接累加for(int i=0;i&lt;x;i++)&#123; for(int j=0;j&lt;y;j++)&#123; res+=dif[i][j]; &#125;&#125;// 多个元素计算前缀和, dif为更新后的numsfor(int i=1;i&lt;=n;i++)&#123; dif[i][0]+=dif[i-1][0];&#125;for(int i=1;i&lt;=m;i++)&#123; dif[0][i]+=dif[0][i-1];&#125;for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=m;j++)&#123; dif[i][j]=dif[i-1][j]+dif[i][j-1]-dif[i-1][j-1]+dif[i][j]; &#125;&#125;"},{"title":"Queue","path":"/wiki/algorithm/dataStructure/queue.html","content":"数组模拟12345678910111213141516171819202122232425262728293031323334353637class Queue&#123; int[] q = new int[1000]; int hh = 0,tt = -1; void add(int x)&#123; q[++t] = x; &#125; int poll()&#123; return q[hh++]; &#125; boolean isEmpty()&#123; return hh &gt; tt; &#125;&#125;// 循环队列, head=tail 为空，(tail+1)=head为满class Q &#123; int size = 100; int[] q = new int[size]; int h = 0, t = 0; boolean offer(int n) &#123; if ((t + 1) % size == h) return false; q[t] = n; t = (t + 1) % size; return true; &#125; int poll() &#123; int res = q[h]; h = (h + 1) % size; return res; &#125; boolean isEmpty() &#123; return h == t; &#125;&#125; 单调队列求 滑动窗口 中的 最值 123456789101112131415161718Deque&lt;Integer&gt; q;int[] nums;//递增队列,队首为窗口最小值for(int i=0;i&lt;nums.length;i++)&#123; // Step 1: 检查队尾元素 while(!q.isEmpty()&amp;&amp;nums[q.peekLast()]&gt;=nums[i]) q.pollLast(); q.add(i); // Step 2: 检查队首元素是否符合要求 // either 窗口大小出队 if(!q.isEmpty()&amp;&amp;q.peekFisrt()&lt;i-size) q.pollFisrt(); // or 队列最小值不满足要求check() while(!q.isEmpty()&amp;&amp;check(nums[q.peekFirst()])) q.pollFisrt(); // Step 3: 队首元素为最值 int curMin= nums[q.peekFirst()];&#125;"},{"title":"Segment Tree","path":"/wiki/algorithm/dataStructure/segment_tree.html","content":"线段树：维护 区间信息 的数据结构，可以在 $\\log n$ 时间内进行一次区间修改&#x2F;查询。空间复杂度为 $m*\\log n$, $m$ 为插入数量, $n$ 为值域, 每次插入最多增加 $\\log n$ 个节点。 面试笔试中通常不会遇到过于复杂的线段树，基本是 max 模型和 sum 模型二选一。这里放一个动态开点的 max 模型，sum 模型只需要改下维护 节点值 和 lazy mark 即可。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//求max模板 -&gt; lc日程表冲突class Node &#123; Node ls, rs; int max, lazy;&#125;void pushUp(Node node) &#123; //使用子节点修改当前节点值 node.max = Math.max(node.ls.max, node.rs.max);// 根据需要修改&#125;void pushDown(Node node) &#123;// 可以附带lc,rc 或len方便修改 if (node.ls == null) node.ls = new Node(); if (node.rs == null) node.rs = new Node(); if (node.lazy != 0) &#123; int add = node.lazy; node.ls.lazy += add;// 修改时需根据需要修改节点值 node.rs.lazy += add; node.ls.max += add; node.rs.max += add; node.lazy = 0; &#125;&#125;// lc,rc 代表当前节点代表的的[l,r], 递归过程中动态维护// l,r 代表当前查询/修改的区间[l,r], 不变void modify(Node node, int lc, int rc, int l, int r, int val) &#123; if (l &lt;= lc &amp;&amp; rc &lt;= r) &#123; node.lazy += val; node.max += val; // 修改时需根据需要修改节点值 &#125; else &#123; pushDown(node); //如果需要分裂，先pushDown int mid = lc + rc &gt;&gt; 1; if (l &lt;= mid) modify(node.ls, lc, mid, l, r, val); if (r &gt; mid) modify(node.rs, mid + 1, rc, l, r, val); pushUp(node); //结束后pushUp，不是必须 &#125;&#125;int query(Node node, int lc, int rc, int l, int r) &#123; if (l &lt;= lc &amp;&amp; rc &lt;= r) return node.max; pushDown(node); int mid = lc + rc &gt;&gt; 1; int res = 0; if (l &lt;= mid) res = query(node.ls, lc, mid, l, r); if (r &gt; mid) res = Math.max(res,query(node.rs, mid+1,rc,l,r)); return res;&#125;"},{"title":"Splay Tree","path":"/wiki/algorithm/dataStructure/splay.html","content":"Splay 树，是一种平衡二叉查找树，它通过 Splay&#x2F;伸展操作 不断将某个节点旋转到根节点，使得整棵树仍然满足二叉查找树的性质，能够在均摊 $O(\\log N)$ 时间内完成插入，查找和删除操作，并且保持平衡而不至于退化为链。 待填坑 ···"},{"title":"Stack","path":"/wiki/algorithm/dataStructure/stack.html","content":"数组模拟12345678910111213141516class Stack&#123; int[] stack=new int[1000]; int ptr=0; void push(int x)&#123; stack[++ptr]=x; &#125; int peek()&#123; return stack[ptr]; &#125; int pop()&#123; return stack[ptr--]; &#125; boolean isEmpty()&#123; return ptr==0; &#125;&#125; 单调栈给定一个序列，对于每个元素，寻找左&#x2F;右侧 第一个比当前元素 更大&#x2F;小 的元素的 值&#x2F;位置，或 一侧比当前元素更小的最大元素 递增栈：寻找最近的比当前元素更小的元素 递减栈：寻找最近的比当前元素更大的元素 求 值&#x2F;位置，stack存 值&#x2F;index，注意是否严格递增 strictly asc&#x2F;desc 用于求解对于某位置的值对结果的总贡献，计算时注意存在相同元素的情况，一边取小于，另一边取小于等于 123456789101112131415161718192021// 寻找左边第一个比它小的数，递增栈int nums[];int min[];Deque&lt;Integer&gt; stack;for (int i = 0; i &lt; nums.length; i++) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek() &gt;= nums[i]) stack.pop(); if (stack.isEmpty()) min[i] = -1;// 当前nums[i]为最小值 else min[i] = stack.peek(); //栈顶元素为最小值 stack.push(nums[i]);&#125;// 寻找右侧比当前元素小的最大元素,递减栈int max[];int k = Integer.MIN_VALUE;for (int i = nums.length - 1; i &gt;= 0; i--) &#123; while (!stack.isEmpty() &amp;&amp; stack.peek() &lt; nums[i]) k = stack.pop(); if (nums[i] &gt; k) max[i] = k; else nums[i] = Integer.MIN_VALUE; //k 值在pop时单调递增，即是小于当前元素的最大值 stack.push(nums[i]);&#125;"},{"title":"Treap","path":"/wiki/algorithm/dataStructure/treap.html","content":"Treap（树堆）是一种 弱平衡 的 二叉搜索树。 待填坑 ···"},{"title":"Union Find","path":"/wiki/algorithm/dataStructure/union_find.html","content":"连通性问题，基本优化路径压缩，按秩合并 1234567891011121314151617181920212223242526272829303132333435363738394041class UF &#123; int[] uf, weight; int cnt; UF(int k) &#123; uf = new int[k]; weight = new int[k]; for (int i = 0; i &lt; k; i++) uf[i] = i; Arrays.fill(weight, 1); cnt = k; &#125; void union(int a, int b) &#123; int ra = find(a), rb = find(b); if (ra == rb) return; cnt--; if (weight[ra] &gt; weight[rb]) &#123; uf[rb] = ra; weight[ra] += weight[rb]; &#125; else &#123; uf[ra] = rb; weight[rb] += weight[ra]; &#125; &#125; int find(int k) &#123; // recursive if (uf[k] != k) uf[k] = find(uf[k]); return uf[k]; &#125; int findRoot(int k) &#123; // iterative int root = k; while (root != uf[root]) root = uf[root]; while (k != root) &#123; int t = uf[k]; uf[k] = root; k = t; &#125; return root; &#125;&#125; weight 存点到根节点的距离 用于维护点组内的关系 12345678910111213// 如x,y,z 三类int find(int a)&#123; if(uf[a]!=a)&#123; int t=find(uf[a]); d[a]+=d[uf[a]]; //维护节点距离 // 注意d[i]为到父节点的距离 // 路径压缩后相加为根节点距离 uf[a]=t; &#125; return uf[a];&#125;// 通过 x,y 同余关系 判断类别关系(d[x] - d[y])%3 != 0"},{"title":"Trie","path":"/wiki/algorithm/dataStructure/trie.html","content":"123456789101112131415161718192021222324252627282930313233343536373839404142class Trie &#123; class Node &#123; boolean isEnd; Node[] next; public Node() &#123; isEnd = false; next = new Node[26]; &#125; &#125; Node root = new Node(); void insert(String word) &#123; Node p = root; for (int i = 0; i &lt; word.length(); i++) &#123; int c = word.charAt(i) - &#x27;a&#x27;; if (p.next[c] == null) p.next[c] = new Node(); p = p.next[c]; &#125; p.isEnd = true; &#125; boolean search(String word) &#123; Node p = root; for (int i = 0; i &lt; word.length(); i++) &#123; int c = word.charAt(i) - &#x27;a&#x27;; if (p.next[c] == null) return false; else p = p.next[c]; &#125; return p.isEnd; &#125; public boolean startsWith(String prefix) &#123; Node p = root; for (int i = 0; i &lt; prefix.length(); i++) &#123; int c = prefix.charAt(i) - &#x27;a&#x27;; if (p.next[c] == null) return false; else p = p.next[c]; &#125; return true; &#125;&#125;"},{"title":"背包 backpack","path":"/wiki/algorithm/dynamicProgramming/backpack.html","content":"背包模型总结第i个物品体积Vi，权值Wi，求装满背包获得最大价值 1234只有完全背包问题 体积从小到大，其余反向枚举for 物品:\tfor 体积: for 决策: 体积最多为j，将f置为0，体积至少为0 体积恰好为j，将f[0]&#x3D;0, 其余 max，体积至少为0 体积至少为j，将f[0]&#x3D;0, 其余 max无限制 枚举体积为 f 时，去掉物品 i 后至少满足体积为 j-v[i]的最少价值，当体积为复数时使用f[0]替代，即满足体积至少为 -5时等价 f[0] 0-1背包每个物品使用0&#x2F;1次，最多1次 flowchart LR id0[\"01背包\"]-->id1[\"状态表示 f[i][j]\"] id1--> id3[\"集合\"]-->id5[\"所有的选法\"] id3-->id6[\"条件：从前 i 个物品中选，总体积"},{"title":"数位DP","path":"/wiki/algorithm/dynamicProgramming/digit.html","content":"模板 123456789101112131415161718192021222324int dfs(int pos, int pre, int lead, int limit) &#123; if (!pos) &#123; 边界条件 &#125; if (!limit &amp;&amp; !lead &amp;&amp; dp[pos][pre] != -1) return dp[pos][pre]; int res = 0, up = limit ? a[pos] : 无限制位; for (int i = 0; i &lt;= up; i ++) &#123; if (不合法条件) continue; res += dfs(pos - 1, 未定参数, lead &amp;&amp; !i, limit &amp;&amp; i == up); &#125; return limit ? res : (lead ? res : dp[pos][sum] = res);&#125;int cal(int x) &#123; memset(dp, -1, sizeof dp); len = 0; while (x) a[++ len] = x % 进制, x /= 进制; return dfs(len, 未定参数, 1, 1);&#125;int main() &#123; cin &gt;&gt; l &gt;&gt; r; cout &lt;&lt; cal(r) - cal(l - 1) &lt;&lt; endl;&#125; 给你一个正整数 n ，请你返回区间 [1, n] 之间 整数的每一位都 互不相同 的 正整数 的数量 1234567891011121314151617181920212223242526272829303132int[][] f;\t// f[i][mask]记录当前选择第i位，已选状态为mask，构造第i位且不受限制的方案数char[] s;public int countSpecialNumbers(int n) &#123; s = Integer.toString(n).toCharArray(); f = new int[s.length][1 &lt;&lt; 10];\t// 一共有s的长度，10个数字的状态 for (int[] a : f) Arrays.fill(a, -1); return search(0, 0, true, false);&#125;// 考虑第n位，状态二进制表示为mask，当前位是否受限(大小)，当前状态是否时合法数字int search(int n, int mask, boolean isLimit, boolean isNum) &#123; if (n == s.length) &#123;\t//边界，搜索完最后一位，是否时合法数字 return isNum ? 1 : 0; &#125; // 注意 memo中记忆的是当前位不受限，且已经不是全为先导0的状态 if (!isLimit &amp;&amp; isNum &amp;&amp; f[n][mask] != -1) return f[n][mask]; int res = 0; // isNum = false 时代表当前选择的全部是0，可以跳过当前位（当前位也选0） if (!isNum) res = search(n + 1, mask, false, false); // 如果当前是受限的，最大值为 s[n] int up = isLimit ? s[n] - &#x27;0&#x27; : 9; // 如果当前状态全部为前导零，则以数字开始，否则也可以选0 // 避免当前选0对已选数字状态的干扰 for (int d = isNum ? 0 : 1; d &lt;= up; d++) &#123; // 枚举没有用过的数字 if ((mask &gt;&gt; d &amp; 1) == 0) // 枚举了数字，则当前数字必然为合法数字，是否受限取决于当前位的值 res += search(n + 1, mask | (1 &lt;&lt; d), isLimit &amp;&amp; d == up, true); &#125; if (!isLimit &amp;&amp; isNum) f[n][mask] = res; return res;&#125; 为何不记录 isLimit 和 isNum 总结：没有重复的情况，不需要记忆 对于isLimit &#x3D; true时，所有前导位全部为最大值。 当 n&#x3D;53210，枚举n&#x3D;4时，x=532***时 limit&#x3D;true ，此时为唯一的情况， 即：不会出现 x=532***且limit&#x3D;true 的情况再次被搜索，也就不需要记忆。 对于limit&#x3D;true时，需要单独枚举，如 235****和532****时方案数量显然不同 同理，当 isNum&#x3D;false 时，前置全部为0，此分支仅搜索当前一次，也不需要记忆。 给定一个整数 n，计算所有小于等于 n 的非负整数中数字 1 出现的个数。 1234567891011121314151617181920212223242526272829// f[i][j]表示在不受is_limit限制且第i位之前有j位为1的条件下，后面几位中可以产生1的个数// 每层递归回返回当前位选d时，所有后续递归的方案所产生的数字中包含1数量的和// 考虑 10x 和 11x，对最后一位所产生的方案所包含的数量不同// 对于情况 104xx 和 140xx 的搜索情况，后续选完xx所产生的数量相同int[][] f;char[] s;public int countDigitOne(int n) &#123; s=Integer.toString(n).toCharArray(); f=new int[s.length][s.length]; for(int i=0;i&lt;s.length;i++)&#123; Arrays.fill(f[i],-1); &#125; return search(0,0,true);&#125;int search(int n,int cnt,boolean isLimit)&#123; if(n==s.length) return cnt; if(!isLimit&amp;&amp;f[n][cnt]!=-1) return f[n][cnt]; int res=0; int up=isLimit?s[n]-&#x27;0&#x27;:9; for(int d=0;d&lt;=up;d++)&#123; res+=search(n+1,cnt+(d==1?1:0),isLimit &amp;&amp; d==up); &#125; if(!isLimit) f[n][cnt]=res; return res;&#125;"},{"title":"区间DP","path":"/wiki/algorithm/dynamicProgramming/interval.html","content":"枚举套路：长度+左端点 12345678910111213int[][] dp;for (int len = 1; len &lt;= n; len++) &#123; // 区间长度 for (int i = 1; i + len - 1 &lt;= n; i++) &#123; // 枚举起点 int j = i + len - 1; // 区间终点 if (len == 1) &#123; dp[i][j] = 初始值 continue; &#125; for (int k = i; k &lt; j; k++) &#123; // 枚举分割点，构造状态转移方程 dp[i][j]=min(dp[i][j], dp[i][k]+dp[k+1][j]+w[i][j]); &#125; &#125;&#125; 石子合并：合并 N 堆石子，每次只能合并相邻的两堆石子，代价为体积和，求最小代价 预处理前缀和，用于计算i-j的区间和 1 环形石子合并 双倍长度dp，选取所有长度为len的结果g[l][l + n - 1] 1"},{"title":"Intro for DP","path":"/wiki/algorithm/dynamicProgramming/intro.html","content":"DP也是面试笔试里面最容易遇到的难题，能不能做出来基本全靠经验。如果是经典的dp模型，则直接转化模板即可。否则大概率需要使用记忆化搜索。 todo经典套路的总结"},{"title":"线性DP","path":"/wiki/algorithm/dynamicProgramming/linear.html","content":"路径 路线代价 序列 LIS (最长上升子序列，Longest Increasing Subsequence) LCS(最长公共子序列，Longest Common Subsequence) LCIS (最长公共上升子序列，Longest Common Increasing Subsequence)"},{"title":"DP优化","path":"/wiki/algorithm/dynamicProgramming/optimize.html","content":"单调队列最大子序和: 输入一个长度为 n 的整数序列，从中找出一段长度不超过 m的连续子序列，使得子序列中所有数的和最大。 枚举子区间的右端点，用 前缀和进行优化 f[i] = max &#123; s[i] - s[j] &#125;, 其中 i-m &lt;= j &lt;= i 将s[i]作为常量，提取后f[i] = s[i] - min&#123; s[j] &#125;, 则转化为窗口中的最小值问题。 1234567891011121314int[] pre = new int[n + 1];for (int i = 1; i &lt;= n; i++) &#123; nums[i] = scan.nextInt(); pre[i] = pre[i - 1] + nums[i];&#125;int res = Integer.MIN_VALUE;Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();q.add(0);for (int i = 1; i &lt;= n; i++) &#123; while (!q.isEmpty() &amp;&amp; (i - q.peekFirst()) &gt; m) q.pollFirst(); res = Math.max(res, pre[i] - pre[q.peekFirst()]); while (!q.isEmpty() &amp;&amp; pre[q.peekLast()] &gt;= pre[i]) q.pollLast(); q.addLast(i);&#125; 旅行问题 斜率&#x2F;&#x2F; todo"},{"title":"状态机DP","path":"/wiki/algorithm/dynamicProgramming/state_machine.html","content":"股票&#x2F;打家劫舍 dp的计算 –&gt; 转化为状态变化路径（最后一步选择的路径） k次交易得到的最大收益 stateDiagram-v2 direction LR 0 --> 1: f[i-1,j,0]-wi 1 --> 0: f[i-1,j-1,1]+wi 0 --> 0: f[i-1,j,0] 1 --> 1: f[i-1,j,1] 状态表示f[i,j,k]: 考虑前 i 天的股票，第 i 天的 决策 是 k，且完成的 完整交易数 为 j 的方案的最大值 买入：k&#x3D;0 → 1 f[i,j,1] = f[i-1,j,0]-wi 买入时还未构成完整交易，j 不变卖出：k&#x3D;1 → 0 f[i,j,0] = f[i-1,j-1,1]+wi 卖出时构成新的交易，从 j-1 转移持仓：k&#x3D;1 → 1 f[i,j,1] = f[i-1,j,1]空仓：k&#x3D;0 → 0 f[i,j,0] = f[i-1,j,0] 需要初始化 -INF：初始化0的话，f[0][j][1]是0，第一次买股票时f[i][j][0]-w[i] 是小于0的，小于f[0][j][1]，就永远不会买股票 12345678910111213141516171819202122232425262728293031323334int[][][] f=new int[n+1][k+1][2];for(int i=0;i&lt;=n;i++)&#123; for(int j=0;j&lt;=k;j++)&#123; Arrays.fill(f[i][j],-INF); &#125;&#125;f[0][0][0]=0;for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;=k;j++)&#123; f[i][j][0]=f[i-1][j][0]; if(j&gt;0) f[i][j][0]=Math.max(f[i][j][0],f[i-1][j-1][1]+s[i]); f[i][j][1]=Math.max(f[i-1][j][1],f[i-1][j][0]-s[i]); &#125;&#125;int res=0;for(int i=0;i&lt;=k;i++)&#123; res=Math.max(res,f[n][i][0]);&#125;//0-1优化int[][] f=new int[k+1][2];for(int j=0;j&lt;=k;j++)&#123; Arrays.fill(f[j],-INF);&#125;f[0][0]=0;for(int i=1;i&lt;=n;i++)&#123; for(int j=k;j&gt;=0;j--)&#123; if(j&gt;0) f[j][0]=Math.max(f[j][0],f[j-1][1]+s[i]); f[j][1]=Math.max(f[j][1],f[j][0]-s[i]); &#125;&#125;int res=0;for(int i=0;i&lt;=k;i++)res=Math.max(res,f[i][0]); 股票带冷冻期 stateDiagram-v2 direction LR 0:空仓 1:持仓 2:冷冻 0 --> 1: f[i-1,0]-wi 1 --> 2: f[i-1,1]+wi 2 --> 0: f[i-1,2] 0 --> 0: f[i-1,0] 1 --> 1: f[i-1,1] 如果第 i 天是 空仓 (j&#x3D;0) 状态，则 i-1 天可能是 空仓 (j&#x3D;0) 或 冷冻期 (j&#x3D;2) 的状态 如果第 i 天是 冷冻期 (j&#x3D;2) 状态，则 i-1 天只可能是 持仓 (j&#x3D;1) 状态，在第 i 天选择了 卖出 如果第 i 天是 持仓 (j&#x3D;1) 状态，则 i-1 天可能是 持仓 (j&#x3D;1) 状态 或 空仓 (j&#x3D;0) 的状态 （买入） 1"},{"title":"树形DP","path":"/wiki/algorithm/dynamicProgramming/tree.html","content":"树的最长路径：树中包含 n 个结点，每条边都有一个权值，找到树中的一条最长路径。 枚举路径的 中间节点，对于每个节点，经过该节点的路径分为 以其 子树中的某个节点 作为 起点，以他作为 终点 的 路径 以其 子树中的某个节点 作为 起点，以 子树中的某个节点 作为 终点 的 路径 以其 子树中的某个节点 作为 起点，以 非其子树的节点 作为 终点 的 路径 对于第 1 种情况，直接递归处理其子树，找出到当前子树根节点最长的路径长度即可 对于第 2 种情况，在处理第 1 种情况时，顺便找出 1 类路径的 次长路径，拼接成为答案 对于第 3 种情况，我们可以把它归类为其 祖先节点 的第 1,2 种情况 1234567891011121314151617181920212223public static void main(String[] args)&#123; //根节点是1，父节点是-1 dfs(1,-1); System.out.println(ans);&#125;int dfs(int u,int father)&#123; int dist = 0; //表示起点为当前点，终点在子树中的最长bian int d1 = 0,d2 = 0; //d1表示最长的边 d2 表示次长的边 //遍历所有子节点 for (int i = h[u];i != -1; i = ne[i])&#123; int j = e[i]; if (j == father) continue; // 仅枚举子节点 int d = dfs(j,u) + w[i]; dist = Math.max(dist,d); if (d &gt;= d1)&#123; d2 = d1; d1 = d; &#125;else if (d &gt; d2) d2 = d; &#125; ans = Math.max(ans,d1 + d2); return dist; &#125; 树的中心（换根DP）：树中包含 n 个结点，每条边有一个权值，找到一个点，使得该点到树中其他点的最远距离最小 指定任意一个根节点 一次dfs遍历，统计出当前子树内的节点对当前节点的贡献 一次dfs遍历，统计出当前节点的父节点对当前节点的贡献，然后合并统计答案 1234567891011121314151617181920212223242526272829303132333435//记录往下走的最长和次长，以及向上走的路径int[] d1 = new int[N],d2 = new int[N],up = new int[N];//记录向下走的最长和次长路径转移路径int[] p1 = new int[N],p2 = new int[N];// 点u向下走的最大距离int dfs_down(int u,int father)&#123; d1[u] = d2[u] = -INF; for (int i = h[u] ; i != -1 ; i = ne[i])&#123; int j = e[i]; if (j == father) continue; int d = dfs_down(j,u) + w[i]; if (d &gt; d1[u])&#123; d2[u] = d1[u];d1[u] = d; p1[u] = j; //存一下最长路径过来的编号 &#125;else if (d &gt; d2[u])&#123; d2[u] = d; p2[u] = j; &#125; &#125; if (d1[u] == -INF) d1[u] = d2[u] = 0; return d1[u];&#125;// 点u的所有子节点j向上走的最大距离void dfs_up(int u,int father)&#123; for (int i = h[u] ; i != -1 ; i = ne[i])&#123; int j = e[i]; if (j == father) continue; //当前点u的向下的最大路径经过j，则用次大值更新j向上走的距离 if (p1[u] == j) up[j] = Math.max(d2[u],up[u]) + w[i]; else up[j] = Math.max(d1[u],up[u]) + w[i]; dfs_up (j,u);//递归更新所有点往上面走的最长路径 &#125;&#125; 树形+状态机 给定一棵包含 n个结点的 树，以及 树 上的 n−1条边，需要在这 n个结点中，选择一定数量的结点放上 哨兵，最终要求，树中任意 n−1条边的左右两端，至少有一个结点上放置了 哨兵，求满足的最少哨兵数量 stateDiagram-v2 direction LR 0:无哨兵0 1:有哨兵1 0-->1:f[j,0] 1-->0:f[j,1] 1-->1:f[j,1] 如果当前结点放置了哨兵(1)，则该子树中，连向他的边的另一端，可以放置(1)，也可以不放置(0)如果当前结点没有放哨兵(0)，则该子树中，连向他的边的另一端，必须可以放置(1) 123456789void dfs(int u)&#123; f[u][0] = 0, f[u][1] = 1; //initialize for (int i = h[u]; ~i; i = ne[i])&#123; int j = e[i]; dfs(j); f[u][0] += f[j][1]; f[u][1] += min(f[j][0], f[j][1]); &#125;&#125; 给定一个含有 n个结点的树，每个结点有一个 权值 wi表示在第 i个点上放置哨兵的花费，于每个 哨兵 来说，他可以 观察 当前结点，以及所有与当前点 相连 的 相邻结点。求解一种放置哨兵的 方案，使得每个 结点 都被 观察 到，且方案的 花费 最小 父节点 放置 哨兵，所有子节点都 可放可不放 哨兵 父节点 不放 哨兵，但是他至少有一个 子节点 放置哨兵，观察住了他 父节点 不放 哨兵，但 父节点 的 父节点 放置哨兵观察，则 子节点 可放可不放 哨兵 被父节点观察 （0）被子节点观察 （1）被自己来观察 （2） stateDiagram-v2 direction LR 0:被父节点观察 （0） 1:被子节点观察 （1） 2:被自己来观察 （2） 0-->2 1-->0 1-->2 2-->2 2-->1 2-->0 12345678910111213141516171819202122232425262728293031323334353637383940f(i, 0)：第i号结点被他的 父结点 安排的守卫看住的方案数f(i, 1)：第i号结点被他的 子结点 安排的守卫看住的方案数f(i, 2)：第i号结点 自己 安排守卫看住的方案数 状态计算:(j是i的子结点)f(i, 0) = sum&#123;min(f(j,1), f(j,2))&#125;i是被他父结点看住的，那他的子结点要么自己看自己，要么被自己的子结点看住 f(i, 1) = min&#123;f(k,2) + sum(min&#123;f(j,1), f(j,2)&#125;)&#125; //j!=ki如果是被子结点看住的，则枚举他是被第k个子结点看住的所有方案 f(i, 2) = sum&#123;min(f(j,0), f(j,1), f(j,2))&#125; + w(i)i是被自己看住的，那他的子结点可以被父结点看住，可以自己看自己，也可以被自己的子结点看住void dfs(int u)&#123; // 自己看自己 f[u][2] = w[u]; int sum = 0; // 枚举子节点j for (int i = h[u] ; i != -1 ; i = ne[i])&#123; int j = e[i]; dfs(j); //u是被父结点看住的，那他的子结点要么自己看自己，要么被自己的子结点看住 f[u][0] += Math.min(f[j][1],f[j][2]); //sum记录为u的所有子节点 j 被j的子节点看住 或 被自己看住 的最小和 sum += Math.min(f[j][1],f[j][2]); //i是被自己看住的，那他的子结点可以被父结点看住，可以自己看自己，也可以被自己的子结点看住 f[u][2] += Math.min(Math.min(f[j][0],f[j][1]),f[j][2]); &#125; f[u][1] = 0x3f3f3f3f; // 枚举所有可能的节点k，使k看住当前节点u // sum为所有子节点被自己或子节点的子节点看住的和，替换其中的k for (int i = h[u] ; i != -1 ; i = ne[i])&#123; int k = e[i]; f[u][1] = Math.min(f[u][1],f[k][2] + (sum - Math.min(f[k][1],f[k][2])) ); &#125;&#125;"},{"title":"Convex Hull 凸包","path":"/wiki/algorithm/geometry/convexhull.html","content":"todo"},{"title":"2D Geometry","path":"/wiki/algorithm/geometry/2d_basic.html","content":"向量（三角形） 向量叉乘cross product$$\\displaylines{对于向量\\overrightarrow{a}(x_1,y_1) 和 \\overrightarrow{b}(x_2,y_2) \\\\数学定义: \\overrightarrow{a}\\times\\overrightarrow{b}&#x3D; x_1 \\cdot y_2 - y_1 \\cdot x_2 \\\\几何意义: \\overrightarrow{a}\\times\\overrightarrow{b}&#x3D;\\left | \\overrightarrow{a} \\right | \\cdot{} \\left | \\overrightarrow{b} \\right |\\cdot \\sin\\theta \\\\等于组成的平行四边形面积}$$ 判断是否为三角形 判断点是否在三角形内部 123456789101112131415161718int product(int x1, int y1, int x2, int y2, int x3, int y3) &#123; //p1p2 向量表示为 (p2.x-p1.x, p2.y-p1.y) //p1p3 向量表示为 (p3.x-p1.x, p3.y-p1.y) return (x2 - x1) * (y3 - y1) - (y2 - y1) * (x3 - x1);&#125;boolean isTriangle(int x1,int y1,int x2,int y2,int x3,int y3)&#123; return x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2) != 0;&#125;// 注意边上是否算在内部boolean inTriangle(int x1, int y1, int x2, int y2, int x3, int y3, int px, int py) &#123; if (product(x1, y1, x2, y2, x3, y3) &lt; 0) &#123; return inTriangle(x1, y1, x3, y3, x2, y2, px, py); &#125; return product(x1, y1, x2, y2, px, py) &gt; 0 &amp;&amp; product(x2, y2, x3, y3, px, py) &gt; 0 &amp;&amp; product(x3, y3, x1, y1, px, py) &gt; 0;&#125; 向量点成dot product$$\\displaylines{对于向量\\overrightarrow{a}(x_1,y_1) 和 \\overrightarrow{b}(x_2,y_2) \\\\数学定义: \\overrightarrow{a}\\cdot\\overrightarrow{b}&#x3D; x_1 \\cdot x_2 + y_1 \\cdot y_2 \\\\几何意义: \\overrightarrow{a}\\times\\overrightarrow{b}&#x3D;\\left | \\overrightarrow{a} \\right | \\cdot{} \\left | \\overrightarrow{b} \\right |\\cdot \\cos\\theta \\\\\\cos \\theta &#x3D;\\frac{\\left | \\overrightarrow{a} \\right | \\cdot{} \\left | \\overrightarrow{b} \\right |}{\\overrightarrow{a}\\cdot\\overrightarrow{b}} \\\\}$$ 12345int product(int x1, int y1, int x2, int y2, int x3, int y3) &#123; //p1p2 向量表示为 (p2.x-p1.x, p2.y-p1.y) //p1p3 向量表示为 (p3.x-p1.x, p3.y-p1.y) return (x2 - x1) * (x3 - x1) + (y2 - y1) * (y3 - y1);&#125; 判断夹角 乘积&gt;0：锐角；&#x3D;0：直角；&lt;0：钝角 计算投影长度 点p的投影与线段AB的关系，用 r&#x3D; 投影长度&#x2F;向量长度 r&lt;0：p投影在A的延长线上 r&#x3D;0：p投影在A点 0&lt;r&lt;1：p投影点在线段AB内 r&#x3D;1：p投影在B点 r&gt;1：p投影在B的延长线上"},{"title":"处理输入输出","path":"/wiki/algorithm/intro/IO.html","content":"通用 Scanner123456789101112131415import java.util.*;public class Main&#123; public static void main(String[] args)&#123; Solution s=new Solution(); s.solve(); &#125;&#125;class Solution&#123; Scanner scan=new Scanner(System.in); void solve()&#123; System.out.println(); &#125;&#125; 大量输入输出 BufferedReader12345678910111213141516171819202122232425262728import java.io.*;import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Solution s = new Solution(); try&#123; s.solve(); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;class Solution &#123; Scanner scan = new Scanner(System.in); void solve()throws IOException &#123; BufferedReader bf = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out)); // 读入 bf.readLine(); // 输出 out.write(&quot;&quot;); out.flush(); &#125;&#125;"},{"title":"数据范围反推算法","path":"/wiki/algorithm/intro/TimeComplexity.html","content":"来源： https://www.acwing.com/blog/content/32/由数据范围反推算法复杂度以及算法内容 运行时间：1s &#x3D;&gt; $10^7 \\sim 10^8$ $n \\leq 30 $, 指数级别，dfs+剪枝，状态压缩 dp $n \\leq 100 \\Rightarrow O\\left(n^{3}\\right) $，floyd，dp，高斯消元 $n \\leq 1000 \\Rightarrow O\\left(n^{2}\\right), O\\left(n^{2} \\log n\\right) $ ， dp，二分，朴素版Dijkstra、朴素版Prim、Bellman-Ford $n \\leq 10^4 \\Rightarrow O(n * \\sqrt{n})$ ，块状链表、分块、莫队 $n \\leq 10^5 \\Rightarrow O(n \\operatorname{logn}) \\Rightarrow$ 各种sort, 线段树、树状数组、set&#x2F;map、heap、拓扑排序、dijkstra+heap、 prim+heap、Kruskal、spfa、求凸包、求半平面交、二分、CDQ分治、整体二分、后缀数组、树链剖分、动态树 $n \\leq 10^6 \\Rightarrow O(n) $, 以及常数较小的 $ O(n \\log n)$ 算法 &#x3D;&gt; 单调队列、hash、双指针扫描、并查集，kmp、AC自动机，常数比较小的 $ O(n \\log n)$ 的做法: sort、树状数s $n \\leq 10^7 \\Rightarrow O(n)$ ，双指针扫描、kmp、AC自动机、线性筛素数 $n \\leq 10^{9} \\Rightarrow O(\\sqrt{n}) $ ，判断质数 $n \\leq 10^{18} \\Rightarrow O(\\log n) $ ，最大公约数，快速幂，数位DP $n \\leq 10^{1000} \\Rightarrow O(\\log^{2} n)$ ，高精度加减乘除 $n \\leq 10^{100000} \\Rightarrow O(\\log k \\times \\log \\log k)$, k 表示位数，高精度加减、FFT&#x2F;NTT"},{"title":"JavaAPI","path":"/wiki/algorithm/intro/javaAPI.html","content":"String &#x2F; Char1234567891011121314151617181920212223242526272829Character.isLetterOrDigit();Character.toLowerCase();Character.toUpperCase();Character.isAlphabetic()Character.isLetter();Character.isDigit()Character.isLowerCase();Character.isSpace();String str=&quot;abcde abcde&quot;;str.charAt(1);str.contains(&quot;ac&quot;);str.indexOf(&quot;b&quot;,1);String[] strList=str.split(&quot; &quot;);//with leading empty str, without trailing emtpy strstr.split(&quot; &quot;, n);//n&gt;0: max result size, n=-1:keep all empty strstr.substring(1,3); //=&gt; &quot;bc&quot;, [1,3)StringBuilder sb=new StringBuilder(str);sb.replace(1,3,&quot;zzz&quot;);// replacedsb.setCharAt(0,&#x27;z&#x27;);sb.append(&quot;abc&quot;);sb.deleteCharAt(7);sb.delete(1,2);// delete [start,end)sb.insert(1,&quot;ab&quot;);// before offset, &quot;aabb..&quot;sb.charAt(1);sb.substring(1,3);// return string[start,end)sb.toString();sb.length();sb.reverse(); TreeMap &#x2F; TreeSet123456789101112131415161718192021222324252627282930TreeMap&lt;Integer,Integer&gt; map=new TreeMap&lt;&gt;((a,b)-&gt;(b-a));// ordered entry/setmap.entrySet();map.keySet();map.values();// sorted by keymap.pollFirstEntry();// get root entrymap.pollLastEntry();map.firstKey(); // return key onlymap.firstEntry();map.lastKey(); // return key onlymap.LastEntry();// Key/Entrymap.ceilingEntry(2);// least key greater than or equalmap.floorEntry(2);// greatest key less than or equalmap.lowerEntry(2);// greatest key strictly less thanmap.higherKey(2);// least key strictly greater than// setTreeSet&lt;Integer&gt; set=new TreeSet&lt;&gt;();set.add(1);set.remove(1);// add 1,2,3, 若无符合要求元素返回nullset.higher(2); //3set.lower(2); //1set.floor(2);\t//2 至多,小于等于2的最大元素set.ceiling(2);\t//2 至少set.first();set.last(); Map1234567891011121314151617181920212223242526//entrysetfor(Map.Entry&lt;String, Integer&gt; entry: numbers.entrySet()) &#123; entry.getKey(); entry.getValue();&#125;for(String str : map.keySet())&#123;&#125;for(int n : map.values())&#123;&#125;// merge// 将oldVal与传入inputVal计算// 若无oldVal,put(key,inputVal)val=map.merge(key,inputVal,(oldVal,inputVal)-&gt;(newVal));// compute// put(key, newValue)// newValue为null则移除entryval=map.compute(key,(key,oldValue)-&gt;(newValue));// computeIfAbsent// key不存在时 put(key, newValue)val=map.computeIfAbsent(key,(key)-&gt;(newValue));// computeIfPresent// key存在时 put(key, newValue)val=map.computeIfPresent(key,(key,oldValue)-&gt;newValue); StreamCreate123456789Stream.of(1,2,3,4,5);// collectionlist.stream();// arrayArrays.stream(new int[]&#123;1,2,3&#125;);// iteratorStream.iterate(0, n -&gt; n + 2).limit(5);// generatorStream.generate(Math::random).limit(5); Intermediate1234567891011121314151617// filterfilter(user -&gt; user.getId() &gt; 6);// map, map to new objectmap(user -&gt; &quot;user: &quot;+ user.getName());// distinct, hashcode &amp; equals()distinct();// sortedsorted(Comparator.comparing(User::getName));sorted((a,b)-&gt;a-b);// limit, return first n elementslimit(5);// skip, drop first n elementsskip(5);// flatMap, put each element into streamflatMap(user -&gt; Arrays.stream(user.getCity().split(&quot;,&quot;)));// peek, modify each elementpeek(user -&gt; user.setId(user.getId()+1)); Terminal123456789101112131415161718192021// collectcollect(Collectors.toSet());collect(Collectors.toList());Map&lt;String, List&lt;Person&gt;&gt; peopleByCity = personStream.collect(Collectors.groupingBy(Person::getCity));// forEachforEach(System.out::println);// findFirstfindFirst().get();// findAnyfindAny().get();// countcount();// min, max, sum =&gt; getAsInt();// boolean anyMatch, allMatch, nonMatch// reduce, reduce([p1,p2,p3,p4],fn) = reduce([fn(p2,p4),fn(p1,p3)])Optional&lt;String&gt; reduced = collection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2); Typical example Accumulate into a List 123List&lt;String&gt; list = people.stream().map(Person::getName)\t.collect(Collectors.toList()); Accumulate names into a TreeSet 123Set&lt;String&gt; set = people.stream() .map(Person::getName) .collect(Collectors.toCollection(TreeSet::new)); Convert elements to strings and concatenate them, separated by commas 123String joined = things.stream() .map(Object::toString) .collect(Collectors.joining(&quot;, &quot;)); Compute sum of salaries of employee 12int total = employees.stream() .collect(Collectors.summingInt(Employee::getSalary)); Group employees by department 12Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); Compute sum of salaries by department 123Map&lt;Department, Integer&gt; totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary))); Partition students into passing and failing 12Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream(). collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD)); count number 1234int[] nums = new int[]&#123;1, 2, 3, 3, 4, 4, 4, 5, 6&#125;;Map&lt;Integer, Long&gt; collect = Arrays.stream(nums) .boxed()\t// int =&gt; Integer .collect(Collectors.groupingBy(a -&gt; a, Collectors.counting()));"},{"title":"Bipartite graph","path":"/wiki/algorithm/graph/bipartite.html","content":"二分图 存在自环则不是二分图 不存在长度为奇数的环 判断dfs&#x2F;bfs 染色 dyeing method 12345678910111213141516171819202122232425262728HashMap&lt;Integer,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;(); // 无向边for (int i = 0; i &lt; m; i++) &#123; // 建图，无向图 int a=scanner.nextInt(), b=scanner.nextInt(); map.computeIfAbsent(a,key-&gt;new ArrayList&lt;&gt;()).add(b); map.computeIfAbsent(a,key-&gt;new ArrayList&lt;&gt;()).add(a);&#125;int[] c = new int[n+1]; // color数组标记节点颜色for (int i = 1; i &lt;= n; i++) &#123; if(c[i] == 0)&#123; // 遍历所有点，未被染色则染色 if(!dfs(i,1))&#123; System.out.println(&quot;No&quot;); return; &#125; &#125;&#125;System.out.println(&quot;Yes&quot;);boolean dfs(int r,int color)&#123; c[r] = color; for(int end : map.getOrDefault(r,new ArrayList&lt;&gt;()))&#123; if(c[end] == color) return false; // 相邻点同色，false if(c[end] == 0)&#123;\t// 相邻点未被染色，递归染色 if(!dfs(end,3 - color)) return false; &#125; &#125; return true;&#125; Maximum match最大匹配 Augmenting Path Algorithm 寻找增广路 augmenting path 按顺序遍历匹配左侧节点，每轮清空st，找到左侧节点可以匹配的右侧节点 若右侧节点i在本轮里没有访问过st[i]=false，访问i 若当前右节点i没有被匹配match[i]=-1, 则匹配，令match[i]=n 若当前节点已经右匹配了，那么递归find(match[i]) 尝试替换先前的匹配 若右侧节点i在本轮里访问过st[i]=true，则说明当前轮次中已经是确定匹配的，跳过防止无限循环。 12345678910111213141516171819202122232425262728// 左侧g.length 个点匹配 右侧 g[0].length 个点// g[i][j]=1 代表 左侧i 与 右侧j 存在一条边，i可以匹配j，默认二分图public int maximumInvitations(int[][] grid) &#123; //lc 1820 int m = grid.length, n = grid[0].length; boolean[] st = new boolean[n]; // 当前轮次是否匹配 int[] match = new int[n]; // 存当前右侧节点匹配的左侧节点 Arrays.fill(match, -1); int res = 0; for (int i = 0; i &lt; m; i++) &#123; // 依次寻找每个左侧的匹配 Arrays.fill(st, false); // 清空已访问 if (find(i, st, match, grid)) res++; // 如果可以匹配，则+1 &#125; return res;&#125;boolean find(int n, boolean[] st, int[] match, int[][] g) &#123; for (int i = 0; i &lt; g[n].length; i++) &#123;//遍历所有可用的匹配边 if (g[n][i] == 0 || st[i]) continue; //如果已经确定匹配 st[i] = true; // 标记匹配 if (match[i] == -1 || find(match[i], st, match, g)) &#123; // 如果当前右节点没有匹配过，直接匹配。 // 或当前与右节点匹配的左节点还有别的选择，则匹配成功 match[i] = n; return true; &#125; &#125; return false;&#125; Maximum weight match最大权匹配Hungarian Algorithm（Kuhn–Munkres Algorithm）&#x2F;&#x2F;todo"},{"title":"Euler circuit/path","path":"/wiki/algorithm/graph/euler.html","content":"欧拉回路：通过图中每条边恰好一次的回路 欧拉通路：通过图中每条边恰好一次的通路 欧拉图：具有欧拉回路的图 欧拉通路存在欧拉路径：起点-入度+1&#x3D;出度，终点-出度&#x3D;入度+1，其余点入度&#x3D;出度 从起点开始，倒序回溯，每次遍历点的所有边，若无边则加入答案栈中。 可以使用优先队列对边进行排序， lc332 123456789101112131415161718192021List&lt;String&gt; res;HashMap&lt;String,PriorityQueue&lt;String&gt;&gt; map;public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123; res=new ArrayList&lt;&gt;(); map=new HashMap&lt;&gt;(); for(List&lt;String&gt; t:tickets)&#123; map.computeIfAbsent(t.get(0),key-&gt;new PriorityQueue&lt;&gt;()).add(t.get(1)); &#125; dfs(&quot;JFK&quot;); Collections.reverse(res); return res;&#125;void dfs(String str)&#123; PriorityQueue&lt;String&gt; q=map.get(str); while(q!=null&amp;&amp;!q.isEmpty())&#123; String next=q.poll(); dfs(next); &#125; res.add(str);&#125; &#x2F;&#x2F; todo"},{"title":"Intro","path":"/wiki/algorithm/graph/intro.html","content":"图论在算法中是非常庞大的存在，但用的不多，绝大多数题也是建图后选择合适的算法打板即可。包含常见算法，过于困难的 连通分量&#x2F;网络流问题 后补。 约定n个点 vertices，m条边 edges 稠密图 Dense graph: $m \\approx n^2$ 稀疏图 Sparse graph: $m \\approx n$ 算法分类 单源最短路径 single source，无负权回路 无负权边 positive weight edge 朴素Dijkstra $\\mathcal{O}( n^2 )$ 适用稠密图 堆优化Dijkstra $\\mathcal{O}( m \\log{n} )$ 适用稀疏图 存在负权边 Negative weight edge Bellman-Ford $\\mathcal{O}( mn )$ - &gt; k step最短路 SPFA 一般 $\\mathcal{O}( m )$, 最差 $\\mathcal{O}( mn )$ 多源最短 Floyd $\\mathcal{O}( n^3 )$，可有&#x2F;无负权环 multi-source 最小生成树 MST minimum spanning tree Prim 稠密图 朴素Prim $\\mathcal{O}( n^2 )$ 堆优化Prim $\\mathcal{O}( m \\log{n} )$ Kruskal $\\mathcal{O}( m \\log{n} )$ 稀疏图 二分图 染色判断 邻接表 $\\mathcal{O}( m+n )$，邻接矩阵 $\\mathcal{O}( n^2 )$ 最大匹配 匈牙利 $\\mathcal{O}( mn )$ 拓扑 $\\mathcal{O}( m+n )$ 欧拉回路，欧拉路径 连通分量Tarjan &#x2F;&#x2F;todo 流问题 &#x2F;&#x2F;todo 数组模拟邻接表12345678910111213141516171819202122232425262728Scanner scanner = new Scanner(System.in);int n = scanner.nextInt();\t// 节点数int m = scanner.nextInt();\t// 边数// int k = scanner.nextInt();int[] start = new int[n+1];\t//起始节点为a的第一条边对应的边编号,headArrays.fill(start, -1); //初始化为没有没有任何边的状态int[] end = new int[m]; //第i条边的结束节点int[] nextEdge = new int[m];//第i条边下一个起始节点为a的边 的编号int[] weight = new int[m];\t//第i条边的权重int idx = 0; //当前最后一个边的位置+1for (int i = 0; i &lt; m; i++) &#123; // a -&gt; b, weight c int a = scanner.nextInt(); int b = scanner.nextInt(); int c = scanner.nextInt(); end[idx] = b; // 编号idx的边的终点 nextEdge[idx] = start[a];\t// 头插，以a开始的边 weight[idx] = c; start[a] = idx++; // 注意无向图，两边都需要添加&#125;// 循环所有起点为s的边:for (int i = start[s]; i != -1; i = nextEdge[i]) &#123; int e = end[i]; int w = weight[i]; // edge: s -&gt; e, w&#125;"},{"title":"状态压缩DP","path":"/wiki/algorithm/dynamicProgramming/state_compression.html","content":"蒙德里安的梦想：n×m的棋盘可以摆放不同的1×2小方格的方案数。 仅考虑 水平摆放 的方块 方案数，剩余位置由垂直方块填充 状态表示：f[i][j] 表示 已经将前 i-1 列摆好，且从第 i−1 列伸出到第 i 列的方格状态是 j 的所有方案。其中j是一个二进制数，用来表示某一行的小方块是横着放的，其位数和棋盘的行数一致。 状态转移： 考虑 i, i-1, i-2 三列，对于水平方块横跨 i-2 和 i-1 列，状态为p。 则对于所有水平方块位于 i-1 和 i 列的状态为 q，需要满足： p与q不重叠 –&gt; p &amp; q == 0 第i-1列剩余方格数为偶数 1234567891011121314151617181920212223242526272829303132333435363738394041int n,m;boolean[] st;List&lt;List&lt;Integer&gt;&gt; ls;// 预处理所有状态，即不能有连续奇数个0for(int i = 0; i &lt; (1&lt;&lt;n); i++)&#123; int cnt = 0; boolean valid = true; for(int j = 0; j &lt; n; j++)&#123; if((i &gt;&gt; j) &amp; 1)&#123; if(cnt &amp; 1 == 1)&#123; valid = false; break; &#125; cnt = 0; &#125;else cnt++; &#125; if(cnt &amp; 1 == 1) valid=false; st[i] = valid;&#125;// 预处理所有状态i可以转移的先导状态jfor(int i = 0; i &lt; (1&lt;&lt;n); i++)&#123; List&lt;Integer&gt; t = new ArrayList&lt;&gt;(); for(int j = 0; j &lt; (1&lt;&lt;n); j++)&#123; // 不能重叠，且没有奇数个0 if((i&amp;j == 0) &amp;&amp; st[i|j])&#123; t.add(j); &#125; &#125; ls.add(t);&#125;int[][] f = new int[m+1][1&lt;&lt;n];f[0][0] = 1; //从第-1列已经完成且没有水平方块延伸到第0列for(int i = 1; i &lt;= m; i++)&#123;\t//枚举列, 1-m列 for(int j = 0; j &lt; (1&lt;&lt;n); j++)&#123; //枚举当前列的状态 for(int k : ls.get(j))&#123;\t//枚举可以转移的状态 f[i][j] += f[i-1][k]; &#125; &#125;&#125;return f[m][0];\t// 第m-1已经放满且没有方块到m列，即第0~m-1均放满 Hamilton路径&#x2F;旅行商问题：n 个点的带权无向图，从0-n经过所有点恰好一次的最短路径 f[i][j] 表示所有从0走到 j, 走过的所有点的情况是 i 的所有路径的最小值 f[i][j]=min(f[i][j],f[i-(1&lt;&lt;j)][k]+w[k][j]) 12345678910111213141516for(int i = 0 ; i &lt; 1 &lt;&lt; n ; i ++ )\tArrays.fill(f[i],0x3f3f3f); f[1][0] = 0;for(int st = 0 ; st &lt; 1 &lt;&lt; n ; st ++ )&#123;//枚举状态 for(int j = 0 ; j &lt; n ; j ++ )&#123;//枚举当前的终点 if((st&gt;&gt;j &amp; 1) == 1)&#123; // 判断当前的状态是否合法（包含终点） for(int k = 0 ; k &lt; n ; k ++ )&#123;// 枚举当前起点 if((st - (1 &lt;&lt; j) &gt;&gt; k &amp; 1) == 1)&#123;//状态包含起点 f[st][j] = Math. min(f[st][j],f[st-(1&lt;&lt;j)][k]+w[k][j]); &#125; &#125; &#125; &#125;&#125;"},{"title":"Shortest Path","path":"/wiki/algorithm/graph/shortest_path.html","content":"Dijkstra基于贪心，每次选取最近的点加入集合 不能存在负权边，无需考虑是否自环，重边取min即可 朴素 $\\mathcal{O}( n^2 )$ 12345dist[1] = 0, dist[-] = INFfor vertices from 1-n //枚举n个点需要 n次循环\tt &lt;- 不在s中且距离最近的点\t//遍历找到当前最近的一个点 一共n*n次 s &lt;- t : 将t加入s中 //s为已经确定最短路的点的集合 使用t点更新其他点的距离 //每次更新当t的所有边 一共m次(边的数量) 12345678910111213141516171819202122232425262728293031323334// 稠密图使用朴素算法，临界矩阵建图int n, m; // n个点，m条边int[][] graph = new int[n + 1][n + 1];int INF = 0x3f3f3f3f;int result = INF;// 建图for (int i = 0; i &lt; n + 1; i++) Arrays.fill(graph[i], INF);for (int i = 0; i &lt; m; i++) &#123; int a, b, c;// a -&gt; b, weight=c; graph[a][b] = Math.min(c, graph[a][b]);&#125;int[] dist = new int[n + 1];boolean[] isVisited = new boolean[n + 1];Arrays.fill(dist, INF); // 将所有点置为不可达dist[start] = 0; // 第一个点距离为0 start -&gt; targetfor(int i = 0;i &lt; n; i ++) &#123; //每一次找到一个点（距离最近的点放入），循环n次 int t = -1; for (int j = 1; j &lt;= n; j++) &#123; // 找到最小值的点 if (!isVisited[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) &#123; //如果该点没有放入集合，并且松弛后距离更小或者当前还没找到点（-1） t = j; &#125; &#125; if (t == target) break;//如果当前最小值是终点，提前break（无法被其他点更新） isVisited[t] = true; for (int j = 1; j &lt; n + 1; j ++) &#123;//依次遍历1-n的点，松弛更新距离 dist[j] = Math.min(dist[j], dist[t] + graph[t][j]); &#125;&#125;if (dist[target] == INF) System.out.println(-1);else System.out.println(dist[target]); 堆优化 $\\mathcal{O}( m \\log{n} )$ 简化每次搜寻最近点，使用堆存储当前所有的点，使用优先队列每次加入新更新的点（堆大小为m）或手写堆更改堆中任意元素（堆大小为n），实际$m &lt;&#x3D; n^2, \\log m &lt;&#x3D; 2\\log n$, 无差别 12345dist[1] = 0, dist[-] = INFfor vertices from 1-n //枚举n个点需要 n次循环 t &lt;- 不在s中，距离最近的点 //使用堆存储，O(1)时间找到最小点，总时间O(n) s &lt;- t : 使用t点更新其他点的距离 //每次更新当前点的所有边,一共m次对插入,共O(m*logn) 1234567891011121314151617181920212223242526272829303132int n,m;// n 点数，m 边数HashMap&lt;Integer,List&lt;int[]&gt;&gt; graph=new HashMap&lt;&gt;();for (int i = 1; i &lt;=n ; i++) graph.put(i,new ArrayList&lt;&gt;());for (int i = 0; i &lt; m; i++) &#123; // a -&gt; b, weight = c; 无向图额外加入 b -&gt; a List&lt;int[]&gt; temp = graph.get(a); temp.add(new int[]&#123;b, c&#125;); &#125;int INF = 0x3f3f3f3f;int[] dist = new int[n + 1];Arrays.fill(dist,INF); // 所有点不可达boolean isVisit[] = new boolean[n + 1];dist[start] = 0; // 起点距离为0，start -&gt; targetPriorityQueue&lt;int[]&gt; queue=new PriorityQueue&lt;&gt;((a,b)-&gt;a[1]-b[1]);queue.add(new int[]&#123;start, 0&#125;);// 小根堆，将起点加入&#123;vertex,dist&#125;while(!queue.isEmpty())&#123; int[] t = queue.poll(); int cur = t[0], w = t[1]; if(cur == target) break;// 找到target提前break if(isVisit[cur]) continue;// 当前点已经更新过,跳过 isVisit[cur] = true; for (int[] next : graph.get(cur)) &#123; // 遍历所有相邻点 if(dist[next[0]] &gt; w + next[1])&#123; // 如果可以更新 dist[next[0]] = w + next[1]; // 更新相邻点的距离 queue.add(new int[]&#123;next[0], w + next[1]&#125;); // 新点入队 &#125; &#125;&#125;if(dist[target] == INF) System.out.println(-1);else System.out.println(dist[target]); Bellman-ford 迭代第n次代表经过n个路径的最短路，需要使用bak防止单次迭代更新多次路径 如果第n次依然发生修改说明存在负权回路（最多n个点，重复访问） 基于dp，只要最短路中不含有负环即可 $\\mathcal{O}( mn )$ 123for n 次\tfor 所有边 a -&gt; b, w dist[b] = min(dist[b], dist[a] + w) 经过n条路径的最短路 1234567891011121314151617181920212223int n, m;int k; // k 步int[][] edges = new int[m][3]; //仅需要所有边的集合for (int i = 0; i &lt; m; i++) &#123; // a -&gt; b, weight = c edges[i][0] = a; edges[i][1] = b; edges[i][2] = c;&#125;int INF = 0x3f3f3f3f;int[] dist = new int[n + 1];Arrays.fill(dist, INF);dist[1] = 0;for (int i = 0; i &lt; k; i++) &#123; int[] distBAK = dist.clone(); //防止串联更新 for (int j = 0; j &lt; m; j++) &#123; //枚举所有边，松弛操作 // 边 a -&gt; b, 使用dist[a] 更新dist[b] int a = edges[j][0], b = edges[j][1], w = edges[j][2]; dist[b] = Math.min(dist[b], distBAK[a] + w); &#125;&#125;if (dist[n] &gt; INF / 2) &#123; //负权边可能会更新距离导致不可达点少于INF System.out.println(&quot;impossible&quot;);&#125; else System.out.println(dist[n]); SPFAShortest Path Faster Algorithm 队列优化版Belman-ford，一般 $\\mathcal{O}( m )$, 最差 $\\mathcal{O}( mn )$ 图中必须不含有负环, 针对bellman-ford算法优化dist[a]未更新时不修改dist[b]，使用队列存储所有优化过的节点进行循环 1234queue &lt;- 起点while !queue.empty t &lt;- queue.pop(); 更新t所有出边 t -&gt; b, if(b被更新) queue &lt;- b 1234567891011121314151617181920212223242526272829303132333435363738int n, m;int[] start=new int[n+1];Arrays.fill(start,-1);int[] end=new int[m];int[] nextEdge=new int[m];int[] weight=new int[m];int idx=0,INF = 0x3f3f3f3f;for (int i = 0; i &lt; m; i++) &#123; int a, b, c; // a -&gt; b, weight=c; end[idx]=b; weight[idx]=c; nextEdge[idx]=start[a]; start[a]=idx++;&#125;int[] dist = new int[n + 1];Arrays.fill(dist, INF);boolean[] inQueue = new boolean[n + 1]; //记录点是否在队列中Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();dist[1] = 0; //起始点距离置0queue.add(1); //起点入队while(!queue.isEmpty())&#123; int v = queue.poll(); inQueue[v] = false; // 出队 for (int i = start[v]; i != -1 ; i = nextEdge[i]) &#123; int e = end[i]; int w = weight[i]; if(dist[e] &gt; dist[v] + w)&#123; // 若可以更新则更新并入队 dist[e] = dist[v] + w; if(!inQueue[e])&#123; // 不在队中，入队 inQueue[e] = true; queue.add(e); &#125; &#125;\t&#125;&#125;if (dist[n] &gt; INF / 2) System.out.println(&quot;impossible&quot;);else System.out.println(dist[n]); 判断负环 使用cnt[i]标记从起点到i点的最短路径所经过的边数，每次更新时使用中间点更新cnt[e] = cnt[v]+1，若从起点到当前点i所经过的路径大于等于n, 则说明至少经过了n+1个点，存在负环。Drawer principle 注意起始时需要将所有点加入队列，需要求任意起点的负权回路 1234567891011121314151617181920212223242526272829303132333435HashMap&lt;Integer, List&lt;int[]&gt;&gt; map = new HashMap&lt;&gt;();for (int i = 0; i &lt; m; i++) &#123; // 邻接表建图 a -&gt; b, weight: c List&lt;int[]&gt; t=map.getOrDefault(a,new ArrayList&lt;&gt;()); t.add(new int[]&#123;b,c&#125;); map.put(a,t);&#125;int[] dist = new int[n + 1];boolean[] inQueue = new boolean[n+1];// 无需初始化起点和距离int[] cnt = new int[n+1]; // 额外数组记录路径数量Deque&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();for (int i = 1; i &lt; n+1; i++) &#123; queue.add(i); // 需要将所有点加入队列，保证能遍历到负环 inQueue[i] = true;&#125;while(!queue.isEmpty())&#123; int v = queue.poll(); inQueue[v] = false; for(int[] next:map.getOrDefault(v, new ArrayList&lt;&gt;()))&#123; if(dist[next[0]] &gt; dist[v] + next[1])&#123; dist[next[0]] = dist[v] + next[1]; cnt[next[0]] = cnt[v] + 1; // 更新最短路上边的数量 if(cnt[next[0]] &gt;= n) &#123; // 存在负环 System.out.println(&quot;Yes&quot;); return; &#125; if(!inQueue[next[0]])&#123; inQueue[next[0]] = true; queue.add(next[0]); &#125; &#125; &#125;&#125;System.out.println(&quot;No&quot;); Floyd多源路径，可有负权边，无负权回路，一般使用邻接矩阵，本质为动态规划，背包优化后为d[i,j] = min(d[i,j], d[i,k] + d[k,j]) 时间 n^3 d[k,i,j]表示从第i个点，经过1 ~ k个中间点，到达j的最短距离 123456789101112131415161718192021222324252627int n, m, p;int[][] g = new int[n + 1][n + 1];int INF = 0x3f3f3f3f;// 初始化邻接矩阵为INF, 自环为0for (int i = 1; i &lt;= n; i++) &#123; Arrays.fill(g[i],INF); g[i][i]=0;&#125;// 建图，重边取最小for (int i = 0; i &lt; m; i++) &#123; int a, b, c; // a -&gt; b, weight: c g[a][b] = Math.min(c, g[a][b]);&#125;// 循环松弛for (int k = 1; k &lt;= n; k++) &#123; // 枚举中间点 for (int i = 1; i &lt;= n; i++) &#123; // 枚举起点 for (int j = 1; j &lt;= n; j++) &#123; // 枚举终点 g[i][j] = Math.min(g[i][k] + g[k][j], g[i][j]); &#125; &#125;&#125;for (int i = 0; i &lt; p; i++) &#123; int a = scanner.nextInt(), b = scanner.nextInt(); if (g[a][b] &gt; INF / 2) &#123; // 负权边可能更新不可达距离 System.out.println(&quot;impossible&quot;); &#125; else System.out.println(g[a][b]);&#125;"},{"title":"Minimum Spanning Tree","path":"/wiki/algorithm/graph/spinning_tree.html","content":"最小生成树 Prim类似dijkstra，每次选取最近的点，同时更新其他点，朴素$\\mathcal{O}( n^2 )$ ，可以堆优化 12345dist[i] &lt;- INFfor i = 0, i &lt; n, i++ t &lt;- 到集合s最近的点 使用t更新其他点到集合的距离 isVisit[t] = true 12345678910111213141516171819202122232425// 邻接矩阵，稠密图int[][] g = new int[n + 1][n + 1];int res = 0, INF = 0x3f3f3f3f;for (int i = 0; i &lt;= n; i++) Arrays.fill(g[i], INF);for (int[] e : connections) &#123; // 建图 int a = e[0], b = e[1], c = e[2]; g[a][b] = g[b][a] = Math.min(c, g[a][b]); // 无向图&#125;boolean[] visit = new boolean[n + 1]; //是否已经放入集合sint[] dist = new int[n + 1];// 当前点到集合最近距离Arrays.fill(dist, INF); // 初始化所有点为INFdist[1] = 0; // 令1为起始点，置距离为0for (int i = 0; i &lt; n; i++) &#123; // 循环n次将n个点放入s int t = -1; for (int j = 1; j &lt;= n; j++) // 找到一个距离最近的点 if (!visit[j] &amp;&amp; (t == -1 || dist[t] &gt; dist[j])) t = j; if (dist[t] == INF) return -1; // 如果最近点距离为INF，不连通 visit[t] = true; res += dist[t]; // t for (int j = 1; j &lt;= n; j++) // 循环更新其他点到集合的距离，注意dijkstra为dist[t]+g[t][j] dist[j] = Math.min(dist[j], g[t][j]); &#125;return res; Kruskal从小到大枚举边，连接所有的点，$\\mathcal{O}( m\\log n )$ 1234将所有边按权值从小到大排序 mlogmfor 每条边 a -&gt; b,w if(a, b不连通) 使用union-find O(m) 将该边加入集合 12345678910111213141516171819202122232425262728293031int minimumCost(int n, int[][] connections) &#123; //con: a-&gt;b,w=c Arrays.sort(connections, (a, b) -&gt; (a[2] - b[2])); //排序 UF uf = new UF(n + 1); int res = 0, cnt = 0;// cnt为加入了多少边 for (int[] e : connections) &#123; // 从小到大枚举所有边 int a = e[0], b = e[1], c = e[2]; if (uf.find(a) != uf.find(b))&#123; // 若边的两点不连通 uf.union(a, b); // 连通两点并将边加入集合 cnt++; res += c; &#125; &#125; if (cnt &lt; n - 1) return -1; //如果集合边数不够，则说明是非连通图 return res;&#125;class UF &#123; int[] uf; UF(int k) &#123; uf = new int[k]; for (int i = 0; i &lt; k; i++) uf[i] = i; &#125; int find(int k) &#123; if (uf[k] != k) uf[k] = find(uf[k]); return uf[k]; &#125; void union(int a, int b) &#123; int ra = find(a), rb = find(b); if (ra != rb) uf[ra] = rb; &#125;&#125;"},{"title":"Topological Sorting","path":"/wiki/algorithm/graph/topo.html","content":"拓扑排序 时间 $\\mathcal{O}( m+n )$ 是否有拓扑排序，即是否存在环 仅针对有向图 入度(in degree)为0的点均可作为起点 123456queue &lt;- 入度为0的点while(queue不为空)\tt &lt;- queue.poll()\t枚举t的所有出边 t -&gt; j 删掉该边，j入度减一 if j 入度为0 : queue &lt;- j 一个有向无环图至少存在一个入度为0的点，统计所有出队的数量是否等于点数判断是否存在环。 12345678910111213141516171819202122232425HashMap&lt;Integer,List&lt;Integer&gt;&gt; map=new HashMap&lt;&gt;();// 邻接表int[] degree=new int[n];\t//数组记录当前节点的入度for(int[] e:prerequisites)&#123; //edge: e[0] -&gt; e[1]\tList&lt;Integer&gt; t=map.getOrDefault(e[0],new ArrayList&lt;&gt;()); t.add(e[1]); map.put(e[0],t);// 建图 degree[e[1]]++;\t//更新入度&#125;Deque&lt;Integer&gt; q=new ArrayDeque&lt;&gt;();for(int i=0;i&lt;n;i++)&#123; if(degree[i]==0) q.add(i); //将入度为0的点作为起点入队&#125;int cnt=0; // 统计当前多少个点已经出队List&lt;Integer&gt; res=new ArrayList&lt;&gt;();while(!q.isEmpty())&#123; int c=q.poll();\t// 队头点出队 cnt++; res.add(c); //记录答案 List&lt;Integer&gt; t=map.get(c); if(t==null) continue; for(int e:t)&#123; // 删除该点所有出边，更新其他点入度 if(--degree[e] == 0) q.add(e); //若入度为0，入队 &#125;&#125;return cnt == n ? res : null ; //若出队点不等于总点数，说明存在环"},{"title":"BigNum 高精度","path":"/wiki/algorithm/math/bignum.html","content":"Arbitrary-Precision Arithmetic todo"},{"title":"Binary Exponentiation 快速幂","path":"/wiki/algorithm/math/binary_exponentiation.html","content":"在 $\\Theta(\\log n)$ 的时间内计算 $a^n$ 的小技巧，而暴力的计算需要 $\\Theta(n)$ 的时间。 1234567891011121314// 时间log ndouble myPow(double x, int n) &#123; boolean isMinus = n &lt; 0; double res = 1; for(int u = Math.abs(n); u != 0; u = u &gt;&gt; 1)&#123; // 左移一位 if((u &amp; 1) == 1)&#123; // 判断最后一位是否为1 res *= x; // 乘上该次幂 &#125; x *= x; // 平方幂 &#125; if(isMinus) return 1 / res; return res;&#125; Inverse element 逆元当 ax≡1(mod b)， x即为 a 在mod b 意义下的逆元，记作 inv(a,b)。 $ a * b \\equiv 1\\bmod p，b是a的在模p下的逆元，存在逆元的冲要条件为a与p互质$ 12345(a + b) % p = (a%p + b%p) %p （对）(a - b) % p = (a%p - b%p) %p （对）(a * b) % p = (a%p * b%p) %p （对）(a / b) % p = (a%p / b%p) %p （错）(a / b) % p = (a * inv(b) ) % p = (a % p * inv(b) % p) % p 123456789101112131415// p必须是质数，使用费马int fermat(int a,int p)&#123; // 求a关于p的逆元 if(a%p==0) return -1; // 倍数存在逆元 return pow(a,p-2)%p; // a^(p-2)快速幂&#125;long pow(long a,long b,long p)&#123; // a^b % p long res=1; while(b!=0)&#123; if(b&amp;1==1) res=res*a%p; b=b&gt;&gt;&gt;1; a=a*a%p; &#125; return res;&#125;"},{"title":"Combinatorics 组合数学","path":"/wiki/algorithm/math/combinatorics.html","content":"Combination 组合数计算 $ C^b_a&#x3D; \\frac{a!}{b!(a-b)!}&#x3D;C_{a-1}^{b}+C_{a-1}^{b-1} (分为包含元素e的方案+不包含元素e的方案)$ 朴素123456int c(int a, int b)&#123;\tint res = 1;\tfor(int i = a, j = 1;j &lt;= b; i--, j++) res = res * i / j;\treturn res;&#125; 预处理所有组合数12345678910111213141516int N;int mod;int[][] c = new int[N][N];void init()&#123; for(int i = 0;i &lt; N; i++)&#123; for(int j = 0; j &lt;= i; j++)&#123; if(j == 0) c[i][j] = 1; else c[i][j] = (c[i - 1][j]+c[i - 1][j - 1])%mod; &#125; &#125;&#125;int cal(int a, int b)&#123; return c[a][b];&#125; 预处理阶乘及逆元$$\\displaylines{C^b_a&#x3D; fact[a]* infact[b-a]*infact[b],\\\\fact[i]&#x3D;i! \\bmod p, \\\\infact[i]&#x3D;(i!)^{-1} \\bmod p}$$ 12345678910111213141516171819202122232425262728int[] fact = new int[N];int[] infact = new int[N];int mod;void init()&#123; fact[0] = 1; infact[0] = 1; for(int i = 1;i &lt; N;i++)&#123; fact[i] = (int) (1L * fact[i-1] * i % mod); // (a * b)^-1 = a^-1 * b^-1; infact[i] = (int)(1L * infact[i - 1] * qmi(i, mod - 2, mod) % mod); &#125;&#125;int query(int a, int b)&#123; return (int) 1L * fact[a] * infact[a-b] % mod * infact[b] % mod;&#125;void qmi(long a, long k, long p)&#123; long res = 1; while(k &gt; 0)&#123; if(k &amp; 1 == 1) res = (res * a) % p; a = a * a % p; k &gt;&gt;= 1; &#125; return (int)res;&#125; Lucas 卢卡斯定理$ C_{a}^{b} \\equiv C_{\\frac{a}{p}}^{\\frac{b}{p}} C_{a \\bmod p}^{b \\bmod p}(\\bmod p) ，对于前半部分递归处理 $ 12345678910111213141516int qmi(long a, long k, long p)&#123;&#125;int C(int a, int b, int p)&#123; if(b &gt; a) return 0; long res = 0; for(int i = 1; j = 1; i &lt;= b; i++, j--)&#123; res = res * j % p; res = res * qmi(i, p-2, p) % p; &#125; return (int) res;&#125;int lucas(long a, long b, long p)&#123; if(a &lt; p &amp;&amp; b &lt; p) return C(a, b, p); return (int)(1L * C(a%p, b%p, p) * lucas(a/p, b/p, p)) % p;&#125; 高精度分解质因数，再高精度乘法$$C^b_a&#x3D; \\frac{a!}{b!(a-b)!}&#x3D; p_1^{a_1} * p_2^{a_2}*p_3^{a_3}…\\求a!中p因数个数&#x3D; \\left \\lfloor \\frac{a}{p} \\right \\rfloor +\\left \\lfloor \\frac{a}{p^2} \\right \\rfloor+\\left \\lfloor \\frac{a}{p^3} \\right \\rfloor+…$$ 1// todo Catalan 卡特兰数 n个结点可构造多少个不同的二叉树？ 一个栈（无穷大）的进栈序列为xxxxx, 有多少个不同的出栈序列 给定 n个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n 的序列，求它们能排列成的所有序列中，能够满足任意前缀序列中 0 的个数都不少于 1 的个数的序列有多少个。 $$ C^n_{2n}-C^{n-1}_{2n} &#x3D; \\frac{C^n_{2n}}{n+1} $$ 1234567891011121314151617int quimi(long a,long k,long p)&#123; long res=1; while(k&gt;0)&#123; if((k&amp;1)==1) res=res*a%p; a=a*a%p; k&gt;&gt;=1; &#125; return (int)res;&#125;int catalan(int n)&#123; long res=1; for(int i=n*2;i&gt;=n+1;i--) res=res*i%p; for(int i=1;i&lt;=n;i++) res=res*quimi(i,p-2,p)%p; res=res*quimi(n+1,p-2,p)%p; return (int) res;&#125; 容斥原理$|A \\cup B \\cup C|&#x3D;|A|+|B|+|C|-|A \\cap B|-|A \\cap C|-|B \\cap C|+|A \\cap B \\cap C|$ 给定整数 n，和 m个质数$ p_1,p_2, …p_m $, 求1~n中能被p中任意一个数整除的数的个数。 1~10中能被2整除的数有{2,4,6,8,10}, 能被3整除的数有： {3,6,9}，既能被2整除，又能被3整除的数有:{6} 。所以所有满足条件的个数为5 + 3 - 1 &#x3D; 7. 对于该题，不需要知道能被某个质数整除的数具体是哪些，只需要知道能被它整除的数有多少个，即集合中的个数 $\\left \\lfloor \\frac{n}{p} \\right \\rfloor $：如果要求既能被2整除，又能被3整除的数有多少个，由于题目中都是质数，所以它们的乘积就是它们的最小公倍数，个数就是 $\\left \\lfloor \\frac{n}{2*3} \\right \\rfloor $。 12// dp状态压缩"},{"title":"hexconvert 进制转换","path":"/wiki/algorithm/math/convert.html","content":"16进制 HEX 0x3f3f 10进制 DEC 8进制 OCT int a = 010 &#x3D;&gt; a=8 2进制 BIN 0b1111&#96; DEC -&gt; P(&lt;10)1234567int n = 19, p = 3;List&lt;Integer&gt; res; // index 0 为个位，需要翻转while(n != 0)&#123; res.add(n % p); n = n / p;&#125;Collection.reverse(res); // 或逆向遍历 P -&gt; DEC1234567String n = &quot;12&quot;, int p = 4;int res = 0;for(int i = n.length() - 1;i &gt;= 0; i++)&#123;\tint val = n.charAt(i) - &#x27;0&#x27;;//根据字符转换数值(ABCD..) res += val + res * p&#125; a -&gt; b12345678910111213141516171819202122String n;int a,b; List&lt;Integer&gt; number=new ArrayList&lt;&gt;(); // index 0 为个位for(int i=n.length()-1;i&gt;=0;i--)&#123; number.add(s.charAt(i)-&#x27;0&#x27;);//将字母及数字转换后的值存入number;&#125;List&lt;Integer&gt; res=new ArrayList&lt;&gt;();while(number.size()&gt;0)&#123; int r=0; for(int k=number.size()-1;k&gt;=0;k--)&#123; // 计算当前number对b的余数 int cur=number.get(k) + a*r;//当前位置的值为余数加上当前值 r=cur%b; number.set(k,cur/b);//每一位计算完成后更新number &#125; res.add(r);//将余数存到res while(number.size()&gt;0&amp;&amp;number.get(number.size()-1)==0)&#123; number.remove(number.size()-1);//去除所有前导零 &#125; // index0 为转换后的个位，需要翻转后输出字符串 Collection.reverse(res); foreach // 将数字转换为字符输出&#125;"},{"title":"Divisor 约数","path":"/wiki/algorithm/math/divisor.html","content":"将数转换成 $ N&#x3D;a_1^{n_1}a_2^{n_2}a_3^{n_3}…$ 试除法求约数时间：$\\log n \\sim \\sqrt n$ 1234567List&lt;Integer&gt; divisor(int n) &#123; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= (int) Math.sqrt(n); i++) &#123; if (n % i == 0 &amp;&amp; n/i != i) res.add(n / i); &#125; return res;&#125; 约数的个数$ n&#x3D; p_1^{n1}p_2^{n2}p_3^{n3}…$ $cnt&#x3D;(n_1+1)(n_2+1)(n_3+1)…$ 123456789Map&lt;Ineteger,Integer&gt; map;for(int i=2;i&lt;=x/i;i++)&#123; while(x%i==0)&#123; x/=i; map.merge(i,1,Integer::sum); &#125;&#125;long res=1;for(int i:map.values()) res*=(i+1); 约数之和$sum&#x3D;(a_1^0+a_1^1+a_1^2+…+a_1^{n_1})(a_2^0+a_2^1+…+a_2^{n_2})…$ 1234567891011121314Map&lt;Integer,Integer&gt; map;for(int i=2;i&lt;=x/i;i++)&#123; while(x%i==0)&#123; x/=i; map.merge(i,1,Integer::sum); &#125;&#125;long res=1;for(Map.Entry&lt;Integer,Integer&gt; e:map.entrySet())&#123; int k=e.getKey(), v=e.getValue(); long t=1; while(v--) t=(t*p+1)%mod; res=(res+t)%mod;&#125;"},{"title":"Euler 欧拉","path":"/wiki/algorithm/math/euler.html","content":"欧拉函数欧拉函数φ(N)表示[1-N]的正整数中与N互质的数的个数 $$\\displaylines{n &#x3D; p_1^{n1}p_2^{n2}p_3^{n3}… \\\\(\\varphi(n)&#x3D; n(1-\\frac{1}{p1})(1-\\frac{1}{p2})(1-\\frac{1}{p3})… \\\\&#x3D; N-\\frac{N}{p_1}-\\frac{N}{p_2}-… +\\frac{N}{p_1p_2}+\\frac{N}{p_1p_3}…-\\frac{N}{p_1p_2p_3}-\\frac{N}{p_1p_2p_4}…}$$ 从1-N中去除 p1,p2, …pk的倍数 加上所有 $ p_i * p_j $ 的倍数 减去所有 $ p_i * p_j * p_k$ 的倍数，再加上 $ p_a * p_b * p_c * p_d $的倍数 … 时间$O(\\sqrt n)$ 12345678int res = n;for(int i = 2; i &lt;= n/i; i++)&#123; if(a%i == 0)&#123; res = res/i*(i-1); while(n%i == 0) n/=i; &#125;&#125;if(n&gt;1) res = res/n*(n-1); 求1-N所有数的欧拉函数 $$\\displaylines{当 i \\bmod p_j &#x3D; 0 时，\\varphi(p_j * i)&#x3D; p_j * \\varphi(i) \\\\当 i \\bmod p_j e 0 时，\\varphi(p_j * i)&#x3D; (p_j-1) * \\varphi(i)}$$ 123456789101112131415161718int[] phi, primes, isPrime;Arrays.fill(isPrime,true);int cnt=0;phi[1]=1;for(int i=2;i&lt;=n;i++)&#123; if(isPrime[i])&#123; primes[cnt++]=i; phi[i]=i-1; &#125; for(int j=0;primes[j]&lt;=n/i;j++)&#123; isPrime[primes[j]*i]=false; if(i%primes[j]==0)&#123; phi[primes[j]*i]=phi[i]*primes[j]; &#125;else&#123; phi[primes[j]*i]=phi[i]*(primes[j]-1); &#125; &#125;&#125; 欧拉定理若a与n互质，则$a^{\\varphi(n)}\\equiv 1 \\bmod n$ 费马小定理 若存在整数 $a,p$，a为整数，p为质数，那么$a^{p-1}\\equiv 1\\bmod p $"},{"title":"Gauss–Jordan elimination 高斯消元","path":"/wiki/algorithm/math/gauss.html","content":"高斯消元法（Gauss–Jordan elimination）是求解线性方程组的经典算法，它在当代数学中有着重要的地位和价值，是线性代数课程教学的重要组成部分。 todo"},{"title":"Game Theory 博弈论","path":"/wiki/algorithm/math/game.html","content":"公平组合游戏（Impartial Game）Nim 游戏Nim 和为0时，该状态为必败状态；否则该状态为必胜状态。 定义 mex 函数的值为不属于集合S中的最小非负整数 todo 非公平组合游戏（Partizan Game）"},{"title":"GCD/LCM","path":"/wiki/algorithm/math/gcd.html","content":"greatest common divisor &#x2F; least common multiple 时间 $\\log(n)$ 123456int gcd(int a,int b)&#123; return b == 0 ? a : gcd(b, a % b);&#125;int lcm(int a,int b)&#123; return a * b / gcd(a, b);&#125; 欧几里得&#x2F;辗转相除法 $$\\displaylines{d|a, d|b \\Rightarrow d|(ax+by) \\\\(a,b) &#x3D; (b, a \\bmod b)\\Leftrightarrow (a,b) &#x3D;(b,a-c\\times b) \\Leftarrow a\\bmod b&#x3D;a- \\left \\lfloor a&#x2F;b \\right \\rfloor \\times b \\\\\\therefore d|a,d|(a-cb)\\Rightarrow d|a,d|(a-cb+cb)}$$ 扩展欧几里得裴蜀定理：对于任意正整数 $a, b$ , 存在非零 $x,y$ 使得 $ ax+by&#x3D;gcd(a,b)$ 12345678910111213141516171819202122232425262728293031323334353637383940414243int exgcd(int a, int b, int[] x, int[] y) &#123; if (b == 0) &#123; x[0] = 1; y[0] = 0; return a; &#125; int d = exgcd(b, a % b, y, x); y[0] -= a / b * x[0]; return d;&#125;int exgcd(int a,int b,int[] x,int[] y)&#123;/** * 扩展欧几里得算法 * 对于任意两个整数a,b，都存在一对x，y使得ax + by = gcd(a,b); * 这个公式是为什么呢 * 因为a 是a和b的最大公约数的倍数，b是a和b的最大公约数的倍数 * 所以ax + by 就是gcd(a,b)的倍数，所以ax + by最小就是gcd(a,b)， * 我们要找的就是这个能凑出最小值的这对x，y **///如果b等于0，那么gcd(a,b)就等于a，所以ax + 0y = a 则 x = 1,y = 0 if(b == 0)&#123; x[0] = 1;y[0] = 0; return a;/** * 由欧几里得算法得：gcd(a,b) = gcd(b,a % b) * 又扩展欧几里得算法得： ax + by = gcd(a,b), bx + (a % b)y = gcd(a,a % b) * 为了方便，将y跟x每次递归都进行换位，因为欧几里得的gcd(a,b) = gcd(b,a % b) * b每次都会换到前面，所以我们跟着换，会省掉很多不必要的换位麻烦 * 所以 by + (a % b)x = gcd(a,b) * 又因 (a % b ) = a - (a / b) * b * 所以 by + (a - (a / b) * b)x = gcd(a,b) * 整理可得 ax + b(y - (a / b) * x) = gcd(a,b) * 所以x还是本身，这就是x跟y每次换位的好处，不用进行变换 * y = y - (a / b) * x 所以每次递归y减掉（a / b ） * x **/ &#125;else&#123; int d = exgcd(b,a % b,y ,x); y[0] -= (a / b) * x[0]; return d;\t&#125;&#125; 线性同余方程 给定a, b, p，求解 x 使得 $ a * x \\equiv b \\bmod p $ 12345678910111213141516171819202122232425262728// ax % p = b ,转化成乘法关系，ax = py + b// 变形得 ax - py = b// 设y1 = -y 得 ax + py1 = b// 利用 扩展欧几里得 求出一个gcd(a,p)即设为d// 求得一对x,y 使得 ax + py = d成立// 要想让ax + py = d 右边变成b的话// 等式两边同时乘以b / d 得到：(b / d)(ax + py) = d * (b / d)// 展开得到: (b / d) ax + (b / d)py = b;// 又因为最开始的a * x ≡ b(mod p) 可以变形为 ax = py + b// 所以 求的x就等于 x * (b / d) % p,int x,int y;long solve(int a,int b,int p)&#123; int d = exgcd(a,p); if(b%d!=0) return -1; else return (long)(b / d) * x % m&#125;int exgcd(int a,int b)&#123; if(b == 0)&#123; x = 1;y = 0; return a; &#125; int d = exgcd(b,a % b); y -= (a / b) * x; return d;&#125; 同余方程组 &#x2F;&#x2F; todo"},{"title":"Matrix 矩阵","path":"/wiki/algorithm/math/matrix.html","content":"vector压缩为(idx, val) 二元组，时间O(n) 乘积，遍历较短的向量，二分较长的向量，乘积时间 O(min(l1,l2)∗log(max(l1,l2)))， l1,l2 为两个向量中非零元素数量。 matrixCOO, coordinate format.COO格式是将矩阵中的非零元素以坐标的方式存储，即将非零元素的行，列，值三个元素记录下来形成的表格。 $$\\displaylines{\\begin{bmatrix}0 &amp; 1 &amp; 0\\\\2 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0\\end{bmatrix}\\Longrightarrow \\begin{vmatrix}x &amp; y &amp; val\\\\0 &amp; 1 &amp; 1\\\\1 &amp; 0 &amp; 2\\end{vmatrix}}$$ CSR&#x2F;CRS or Yale format$$\\displaylines{\\begin{bmatrix}10 &amp; 20 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 30 &amp; 0 &amp; 40 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 50 &amp; 60 &amp; 70 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 80\\end{bmatrix}\\Longrightarrow \\begin{vmatrix}Val &amp; &#x3D; &amp;[&amp; 10 &amp;20 &amp;30 &amp;40 &amp;50 &amp;60 &amp;70 &amp;80 &amp;] \\\\COL &amp; &#x3D;&amp;[ &amp; 0 &amp; 1 &amp; 1 &amp; 3 &amp; 2 &amp; 3 &amp; 4 &amp;5 &amp;] \\\\ROW &amp; &#x3D;&amp;[ &amp; 0 &amp; 2 &amp; 4 &amp; 7 &amp; 8 &amp; ] &amp; &amp; &amp;\\end{vmatrix}}$$ Row index 代表每一行的第一个非0元素的列下标。可将row_index看做指向(Col_index, Val)的指针，指向每一行。 矩阵乘123456789101112131415161718192021222324252627282930313233343536373839404142public int[][] multiply(int[][] m1, int[][] m2) &#123; List&lt;int[]&gt; r1=new ArrayList&lt;&gt;(),c1=new ArrayList&lt;&gt;(); List&lt;Integer&gt; r2=new ArrayList&lt;&gt;(),c2=new ArrayList&lt;&gt;(); int l1=m1.length,w1=m1[0].length,l2=m2.length,w2=m2[0].length; int[][] res=new int[l1][w2]; int idx=0; for(int i=0;i&lt;l1;i++)&#123; r2.add(idx); for(int j=0;j&lt;w1;j++)&#123; if(m1[i][j]!=0)&#123; r1.add(new int[]&#123;j,m1[i][j]&#125;); idx++; &#125; &#125; &#125; r2.add(idx); idx=0; for(int j=0;j&lt;w2;j++)&#123; c2.add(idx); for(int i=0;i&lt;l2;i++)&#123; if(m2[i][j]!=0)&#123; c1.add(new int[]&#123;i,m2[i][j]&#125;); idx++; &#125; &#125; &#125; c2.add(idx); for(int i=0;i&lt;r2.size()-1;i++)&#123; for(int j=0;j&lt;c2.size()-1;j++)&#123; int rstart=r2.get(i),rend=r2.get(i+1); int cstart=c2.get(j),cend=c2.get(j+1); while(rstart&lt;rend&amp;&amp;cstart&lt;cend)&#123; int rpos=r1.get(rstart)[0],cpos=c1.get(cstart)[0]; if(rpos==cpos) res[i][j]+=r1.get(rstart++)[1]*c1.get(cstart++)[1]; else if(rpos&gt;cpos) cstart++; else rstart++; &#125; &#125; &#125; return res;&#125; DIA, the diagonal sparse matrix format沿着对角线划分矩阵，主对角线的指标为0，左下方的对角线依次用-1，-2 等表示，右上方的对角线分布用1,2,3等表示。存储对角线上的元素值。"},{"title":"pigeonhole principle 抽屉原理","path":"/wiki/algorithm/math/pigeon.html","content":"todo"},{"title":"Prime 质数","path":"/wiki/algorithm/math/prime.html","content":"质数定理：1-n个数中有n&#x2F;ln(n)个质数 判断朴素$\\mathcal{O}( n )$, 优化$\\mathcal{O}( \\sqrt n)$ 1234567bool isPrime(int n)&#123; if (n &lt; 2) return false; for (int i = 2; i &lt;= n / i; i++)&#123; if (n % i == 0) return false; &#125; return true;&#125; 求质因数1234567891011121314151617void prime(int a)&#123; int b=(int)Math.sqrt(a); for (int i = 2; i &lt;=b; i++) &#123; int count=0; while(a%i==0)&#123; count++; a/=i; &#125; if(count!=0)&#123; System.out.println(i+&quot; &quot;+ count); &#125; &#125; if(a!=1)&#123; // a为质数 System.out.println(a+&quot; 1&quot;); &#125; System.out.println();&#125; 质数筛朴素时间$\\mathcal{O}( n\\log n )$ 123456789101112131415void prime(int n)&#123; int count=0; boolean[] isPrime =new boolean[n+1]; Arrays.fill(isPrime,true); for (int i = 2; i &lt;= n; i++) &#123; if(isPrime[i])&#123; count++; &#125; for (int j = i*2; j&lt;=n ; j=j+i) &#123; isPrime[j]=false; &#125; &#125; System.out.println(Arrays.toString(isPrime)); System.out.println(count);&#125; 埃氏筛仅去除所有质数的倍数 时间 $\\mathcal{O}( n\\log (\\log n) )$ ，约 $\\mathcal{O}( n )$ 123456789101112131415void prime(int n)&#123; int count = 0; boolean[] isPrime = new boolean[n+1]; Arrays.fill(isPrime,true); for (int i = 2; i &lt;= n; i++) &#123; if(isPrime[i])&#123; count++; for (int j = i*2; j&lt;=n ; j=j+i) &#123; isPrime[j] = false; &#125; &#125; &#125; System.out.println(Arrays.toString(isPrime)); System.out.println(count);&#125; 线性筛仅把最小质因数筛去 时间 $\\mathcal{O}( n )$ 当筛去8（4*2）后，break；不继续计算 4*3 因为后面12（4*3）会被（6*2）筛去。因为2已经是4的因数，所以12必然会被后面（某个数*2）删去，做到每个数都被最小的质因数筛去达到线性。 第一次 Prime: 2 2*2 4 第二次 Prime: 2,3 3*2 3*3 6,9 第三次 Prime: 2,3 4*2 8 第四次 Prime: 2,3,5 5*2 5*3 5*5 10,15,25 第五次 Prime: 2,3,5 6*2 12 第六次 Prime: 2,3,5,7 7*2 7*3 7*5 7*7 14,21,35,49 第七次 Prime: 2,3,5,7 8*2 16 第八次 Prime: 2,3,5,7 9*2 9*3 18,27 1234567891011121314151617181920void prime(int n) &#123; int count = 0; boolean[] isPrime = new boolean[n + 1]; int[] Prime = new int[n]; Arrays.fill(isPrime, true); for (int i = 2; i &lt;= n; i++) &#123; if (isPrime[i]) &#123; Prime[count++] = i; &#125; for (int j = 0; Prime[j] &lt;= n / i; j++) &#123; isPrime[Prime[j] * i] = false; if (i % Prime[j] == 0) &#123; break; &#125; &#125; &#125; System.out.println(Arrays.toString(Prime)); System.out.println(Arrays.toString(isPrime)); System.out.println(count);&#125;"},{"title":"Random/Sample 随机抽样","path":"/wiki/algorithm/math/random.html","content":"蓄水池抽样针对不能将全部内容加载到内存的序列中随机取样，在线算法 如一个未知行数的大文件中抽取一行，仅能顺序读取，无法加载至内存 抽一行12345678910111213i = 0 &lt;= 当前读到的行数s = null &lt;= 选择的行for line in file:\ti++;\tr = random(0,i); &lt;= 取[0,i)的随机数\tif r == 0: s = line; &lt;= 如果r为0则用当前行替换答案return s; &lt;= 当读完文件则以1/n返回当前n行中的任意一行 读第一行 读第二行 读第三行line 1: P = 1 1*(1-1/2) = 1/2 1/3 line 2: 1/2 1/2 * (1 - 1/3) = 1/3line 3: 1/3 链表随机抽取节点123456789101112131415161718class Solution &#123; ListNode head; Random random; public Solution(ListNode head) &#123; this.head = head; random = new Random(); &#125; public int getRandom() &#123; int i = 1, ans = 0; for(ListNode node = head; node != null;node = node.next) &#123; if (random.nextInt(i++) == 0) &#123; // 1/i的概率选中当前行 ans = node.val; &#125; &#125; return ans; &#125;&#125; 抽取k行（不同的）1234567891011i = 0 &lt;= 当前读到的行数s = [] &lt;= 选择的数组for line in file:\ti++;\tif i &lt; k: &lt;= 若不足k行，则直接选择 s.add(line); else: r = random(0,i); &lt;= 取[0,i)的随机数 if r &lt; k: s[r] = line; &lt;= 如果r为0则用当前行替换s[r]行return s;"},{"title":"Bracket Seq 括号序列","path":"/wiki/algorithm/unclassified/bracket_seq.html","content":"todo"},{"title":"Calculator","path":"/wiki/algorithm/unclassified/calculator.html","content":"Reverse Polish Expression 计算器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();Deque&lt;Character&gt; op = new ArrayDeque&lt;&gt;();Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();int calculate(String s) &#123; char[] str = s.replace(&quot; &quot;, &quot;&quot;).toCharArray(); map.put(&#x27;+&#x27;, 1); map.put(&#x27;-&#x27;, 1); map.put(&#x27;*&#x27;, 2); map.put(&#x27;/&#x27;, 2); int ne = 1; for (int i = 0; i &lt; str.length; i++) &#123; char c = str[i]; if (Character.isDigit(c)) &#123; int v = 0; while (i &lt; str.length &amp;&amp; Character.isDigit(str[i])) &#123; v = v * 10 + str[i++] - &#x27;0&#x27;; &#125; stack.push(v * ne); ne = 1; i--; &#125; else &#123; if (c == &#x27;(&#x27;) &#123; op.push(c); &#125; else if (c == &#x27;)&#x27;) &#123; while (op.peek() != &#x27;(&#x27;) eval(); op.pop(); &#125; else &#123; if (c == &#x27;-&#x27; &amp;&amp; (i == 0 || (str[i - 1] == &#x27;(&#x27; || map.containsKey(str[i - 1])))) &#123; ne = -1; continue; &#125; while (!op.isEmpty() &amp;&amp; op.peek() != &#x27;(&#x27; &amp;&amp; map.get(op.peek()) &gt;= map.get(c)) &#123; eval(); &#125; op.push(c); &#125; &#125; &#125; while (!op.isEmpty()) eval(); return stack.pop();&#125;void eval() &#123; int b = stack.pop(); int a = stack.pop(); char c = op.pop(); if (c == &#x27;+&#x27;) stack.push(a + b); else if (c == &#x27;-&#x27;) stack.push(a - b); else if (c == &#x27;*&#x27;) stack.push(a * b); else if (c == &#x27;/&#x27;) stack.push(a / b);&#125;"},{"title":"排序数组去重","path":"/wiki/algorithm/unclassified/remove_duplicate.html","content":"123456789int[] nums; // sorted arrayint left=0,right=1;while(right&lt;nums.length)&#123; if(nums[left]!=nums[right])&#123; nums[++left]=nums[right]; &#125; right++;&#125;return left; //[0,left] unique element"},{"title":"Two Pointer/Sliding Window","path":"/wiki/algorithm/unclassified/twopointer.html","content":"子序列匹配 todo lc 524 链表找环滑动窗口 枚举左端点 枚举右端点"},{"title":"Moore 摩尔投票","path":"/wiki/algorithm/unclassified/vote.html","content":"1234567891011121314151617181920212223242526272829303132333435int majorityElement(int[] nums) &#123; int n=0,cnt=0; for(int a:nums)&#123; if(a==n) cnt++; else&#123; if(cnt&gt;1)cnt--; else n=a; &#125; &#125; return n;&#125;// k/nList&lt;Integer&gt; majorityElement(int[] nums) &#123;\tint n = nums.length; int a = 0, b = 0; int c1 = 0, c2 = 0; for (int i : nums) &#123; if (c1 != 0 &amp;&amp; a == i) c1++; else if (c2 != 0 &amp;&amp; b == i) c2++; else if (c1 == 0 &amp;&amp; ++c1 &gt;= 0) a = i; else if (c2 == 0 &amp;&amp; ++c2 &gt;= 0) b = i; else &#123; c1--; c2--; &#125; &#125; c1 = 0; c2 = 0; for (int i : nums) &#123; if (a == i) c1++; else if (b == i) c2++; &#125; List&lt;Integer&gt; ans = new ArrayList&lt;&gt;(); if (c1 &gt; n / 3) ans.add(a); if (c2 &gt; n / 3) ans.add(b); return ans;&#125;"},{"title":"lab1","path":"/wiki/database_lab/lab1/lab1.html","content":"lab1 需要完成一下几个部分 Tuple, TupleDesc Catalog BufferPool HeapPage, HeapFile SeqScan 先看看都有什么 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990simpledb│ Parser.java│ ParsingException.java│ SimpleDb.java│├─common│ Catalog.java│ Database.java│ DbException.java│ DeadlockException.java│ Debug.java│ Permissions.java│ Type.java│ Utility.java│├─execution│ Aggregate.java│ Aggregator.java│ Delete.java│ Filter.java│ HashEquiJoin.java│ IndexOpIterator.java│ IndexPredicate.java│ Insert.java│ IntegerAggregator.java│ Join.java│ JoinPredicate.java│ Operator.java│ OpIterator.java│ OrderBy.java│ PlanCache.java│ Predicate.java│ Project.java│ Query.java│ SeqScan.java│ StringAggregator.java│├─index│ BTreeChecker.java│ BTreeEntry.java│ BTreeFile.java│ BTreeFileEncoder.java│ BTreeHeaderPage.java│ BTreeInternalPage.java│ BTreeLeafPage.java│ BTreePage.java│ BTreePageId.java│ BTreeRootPtrPage.java│ BTreeScan.java│ BTreeUtility.java│├─optimizer│ CostCard.java│ IntHistogram.java│ JoinOptimizer.java│ LogicalFilterNode.java│ LogicalJoinNode.java│ LogicalPlan.java│ LogicalScanNode.java│ LogicalSelectListNode.java│ LogicalSubplanJoinNode.java│ OperatorCardinality.java│ QueryPlanVisualizer.java│ StringHistogram.java│ TableStats.java│├─storage│ AbstractDbFileIterator.java│ BufferPool.java│ DbFile.java│ DbFileIterator.java│ Field.java│ HeapFile.java│ HeapFileEncoder.java│ HeapPage.java│ HeapPageId.java│ IntField.java│ LogFile.java│ Page.java│ PageId.java│ RecordId.java│ StringField.java│ Tuple.java│ TupleDesc.java│ TupleIterator.java│└─transaction Transaction.java TransactionAbortedException.java TransactionId.java 首先需要关注的： Database.java：提供catalog（库中表的信息），buffer pool，log StringField &amp; IntField： 唯二的两个数据类型 Tuple：数据行，包含多个Field TupleDesc：表头，tuple descriptor TupleIterator：Tuple 游标，用于遍历tuple list Exercise 1Implement TupleDesc.java &amp; Tuple.java观察一下，从表头开始写，因为 Tuple 中需要用到 TupleDesc。 TupleDesc实现：用给定内部类 TDItem 来存表头的字段信息，包含 type 和 name。坑： 求单行所占用的数据大小 size 的具体数值在 Type.getLen() 提供 给的 fieldAr 数组中的表头名可能为 null, equals() 需要特判 https://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/TupleDesc.javahttps://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/TupleDesc.java Tuple实现：创建 Field 数组用于存储数据 modifyRecordId 暂时会 fail，不影响 https://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/Tuple.javahttps://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/Tuple.java Exercise 2Implement Catalog.java 根据描述， Catalog 存储了所有表的信息，包含表的物理存储文件 DbFile 以及主键信息 pkeyField。 实现：4 * HashMap，维护 name, id, file, pk 的映射 https://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/common/Catalog.javahttps://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/common/Catalog.java Exercise 3Implement getPage() in BufferPool.java 这里要求从 BufferPool 中返回 PageId 对应的 page，如果没有就要把 page 从 disk 上读出来放到 pool 中。对于没有的 page，代码里没有明说从哪里读，但是从前面的部分可以推测肯定是从 DbFile 中读取，因为 DbFile 存着表的数据。 观察 Catalog 以及 PageId，可以发现 PageId 包含了 tableId 而 Catalog 维护了 tableId 到物理文件 DbFile 的映射。再看 DbFile，里面也提供了需要的 Page readPage(PageId id)。 剩下的没啥好说的，直接从 Catalog 用 tableId 拿到 DbFile，再用 readPage 把 page 读进来丢到 HashMap 里即可。 这部分要求如果满了就抛 DbException，不需要 eviction policy。 唯一不确定的就是 BufferPool 被标记为 @ThreadSafe，不知道需不需要用 ConcurrentHashMap。 https://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/BufferPool.javahttps://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/BufferPool.java Exercise 4Implement HeapPageId.java, RecordId.java, HeapPage.java 完成 HeapPage 及相关的基本操作 HeapPageId：存 tableId 和 pgNo, 假设MAX_PAGES_PER_TABLE = 100000 计算 hashCode()。 RecordId：存 PageId 和 tupleNo, 假设MAX_TUPLES_PER_PAGE = 10000 计算 hashCode()。 HeapPage：由 header[] 和 tuples[] 构成，其中 header 为 bitmap，标记对应 slot 是否有数据，tuples[] 则存储具体数据。 其中稍微复杂的部分是计算 header 部分，但 lab 代码中已经给出了计算公式，位运算直接照抄即可，具体对应方法为 Big-endian。 The low (least significant) bits of each byte represents the status of the slots that are earlier in the file. Hence, the lowest bit of the first byte represents whether or not the first slot in the page is in use. The second lowest bit of the first byte represents whether or not the second slot in the page is in use, and so on. Also, note that the high-order bits of the last byte may not correspond to a slot that is actually in the file, since the number of slots may not be a multiple of 8.tuples per page = floor((BufferPool.getPageSize()*8) / (tuple size * 8 + 1))header bytes = ceiling(tuples per page / 8) https://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/HeapPage.javahttps://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/HeapPage.java Exercise 5Implement HeapFile 这部分需要实现存储实际数据的 DbFile 读取操作，lab 代码中空空如也，不过好在 instruction 中有所提示。 先是 ReadPage(PageId pid)，是从 DbFile 中读取指定的 Page。 To read a page from disk, you will first need to calculate the correct offset in the file. Hint: you will need random access to the file in order to read and write pages at arbitrary offsets. You should not call BufferPool instance methods when reading a page from disk. 关键词: random access, offset 暗示使用 RandomAccessFile 来从指定 offset 来读取 byte 数组，读取后创建新的 HeapPage 返回即可。不知道给的 PageId 是不是 HeapPageId，保险起见没有强转。 然后是 DbFileIterator，要求迭代当前 DbFile 中所有的 Tuple，并且 Page 必须从 BufferPool 中获取。实现为按顺序获取各个 page 的 iterator，遍历 Tuple。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// see DbFile.java for javadocspublic DbFileIterator iterator(TransactionId tid) &#123; // TODO: some code goes here return new DbFileIterator() &#123; private final int numPages = numPages(); private final BufferPool bufferPool = Database.getBufferPool(); private final int tableId = getId(); private int currentPageNo; private Iterator&lt;Tuple&gt; pageIter; @Override public void open() throws DbException, TransactionAbortedException &#123; currentPageNo = 0; pageIter = getIterator(); &#125; Iterator&lt;Tuple&gt; getIterator() throws TransactionAbortedException, DbException &#123; if (currentPageNo &gt;= numPages) return null; HeapPageId pid = new HeapPageId(tableId, currentPageNo); return ((HeapPage) bufferPool.getPage(tid, pid, Permissions.READ_ONLY)).iterator(); &#125; @Override public boolean hasNext() throws DbException, TransactionAbortedException &#123; while (pageIter != null &amp;&amp; !pageIter.hasNext()) &#123; currentPageNo++; pageIter = getIterator(); &#125; return pageIter != null; &#125; @Override public Tuple next() throws DbException, TransactionAbortedException, NoSuchElementException &#123; if (pageIter == null || !pageIter.hasNext()) throw new NoSuchElementException(); Tuple res = pageIter.next(); hasNext(); return res; &#125; @Override public void rewind() throws DbException, TransactionAbortedException &#123; close(); open(); &#125; @Override public void close() &#123; pageIter = null; currentPageNo = numPages; &#125; &#125;;&#125; https://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/HeapFile.javahttps://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/storage/HeapFile.java Exercise 6Implement SeqScan 直接使用 DbFile 的 iterator 遍历 file 的所有 tuple 即可。注意 getTupleDesc() 需要更改 fieldName （alias.fieldName）。 https://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/execution/SeqScan.javahttps://github.com/JingleG/6.830-java/blob/lab1/src/java/simpledb/execution/SeqScan.java 总结难度：有手就行，仔细看看 lab 的注释 和 instruction 一晚上即可拿下，没啥好说的。 附赠 lab1 一键测试脚本，放入 build.xml 即可，不报错默认通过，使用 IDEA 需要取消 ant 的 make build in background 可以看到测试细节。 123456789101112131415161718&lt;target name=&quot;lab1&quot; depends=&quot;testcompile&quot; description=&quot;Run all unit tests&quot;&gt; &lt;RunJunit timeoutMs=&quot;$&#123;timeoutMs&#125;&quot;&gt; &lt;batchtest&gt; &lt;fileset dir=&quot;$&#123;build.test&#125;&quot;&gt; &lt;include name=&quot;**/TupleTest.class&quot;/&gt; &lt;include name=&quot;**/TupleDescTest.class&quot;/&gt; &lt;include name=&quot;**/CatalogTest.class&quot;/&gt; &lt;include name=&quot;**/HeapPageIdTest.class&quot;/&gt; &lt;include name=&quot;**/RecordIDTest.class&quot;/&gt; &lt;include name=&quot;**/HeapPageReadTest.class&quot;/&gt; &lt;include name=&quot;**/HeapFileReadTest.class&quot;/&gt; &lt;include name=&quot;**/systemtest/ScanTest.class&quot;/&gt; &lt;exclude name=&quot;**/*$*.class&quot;/&gt; &lt;/fileset&gt; &lt;/batchtest&gt; &lt;/RunJunit&gt; &lt;echo message=&quot;All tests passed successfully!&quot;/&gt;&lt;/target&gt; 还有当时做lab时画的图，虽然不是很准确，可以拿来参考。"},{"title":"lab2","path":"/wiki/database_lab/lab2/lab2.html","content":"lab2content"},{"title":"A*/IDA*","path":"/wiki/algorithm/search/a_start.html","content":"A*使用 代价函数 及 优先队列 的 BFS 必须满足有解，否则优先队列代价大于朴素bfs 仅保证到达终点的代价最优，不保证过程中的状态，且状态出队不判重 搜索最短距离，使用启发函数（估价函数）减少搜索范围，使用优先队列代替bfs中的队列 队列存储 当前真实距离$f(x)$ 和 到达最终状态的估计距离$h^*(x)$，每次选择总代价$f(x)+h^*(x)$最小的状态出队 对于启发函数 $h^*(x)$，必须满足状态 x 到最终状态的真实距离函数$h(x) \\ge h^*(x)$，当$h^*(x)&#x3D;0$时成为Dijkstra 第k短路问题：n个点m条边的有向图，求从起点s到终点t的第k短路的长度，可以重复经过点或边 1// todo IDA*迭代加深配合A*，估价函数 小于 真实值 在迭代加深搜索时，如果当 估计代价 已经大于搜索限制，直接返回 &#x2F;&#x2F; todo"},{"title":"BFS","path":"/wiki/algorithm/search/bfs.html","content":"朴素BFS使用队列按层搜索 求最小&#x2F;最短 迭代，空间使用小 123456789101112Deque&lt;st&gt; q;q.add(start_state);while(q.size()&gt;0)&#123; st cur=q.poll(); // find result, return if(cur==end) return; // enumerate all possible next_state for(nst: new_states)&#123; check_duplicate(nst); q.add(nst); &#125;&#125; 双向BFS使用两个队列分别从起点和终点搜索，每次使用搜索范围小的队列扩展搜索，加快搜索速度。 搜索连通距离1234567891011121314151617181920212223242526272829303132333435// 使用两个map分别记录两边状态的距离map1.put(st, 0);map2.put(ed, 0); q1.add(st);q2.add(ed);while (q1.size() &gt; 0 &amp;&amp; q2.size() &gt; 0) &#123; // 当两个队列不空, 如果为空则不连通 int cur; if (q1.size() &lt; q2.size()) &#123;\t// 选择较小的队列搜索 cur = bfs(q1, map1, map2, a, b); &#125; else &#123; cur = bfs(q2, map2, map1, b, a); &#125; if (cur &lt;= 10) &#123; // 如果有答案，结束搜索 System.out.println(cur); return; &#125;&#125;int bfs(Deque&lt;String&gt; q1, map1, map2) &#123; int size = q1.size(); for (int i = 0; i &lt; size; i++) &#123; // 枚举该层 String cur = q1.poll(); ... // 枚举从cur =&gt; ns 状态的可行转移 if (!map1.containsKey(ns)) &#123; // 如果当前状态没有搜索过，加入队列和dist中 q1.add(ns); map1.put(ns, map1.get(cur) + 1); if (map2.containsKey(ns)) &#123;\t// 如果此状态被另一边搜索过，则找到最小值 return map1.get(ns) + map2.get(ns); &#125; &#125; &#125; return 1000;&#125;"},{"title":"DFS","path":"/wiki/algorithm/search/dfs.html","content":"DFS的剪枝优化 优化搜索顺序：选择搜索分支数量少的节点 排序，从大到小枚举 排除等效冗余：是否考虑顺序，不搜索重复的状态 可行性剪枝：如果发现不合法，则提前结束搜索 最优性剪枝：如果当前状态已经不是最优解，提前结束 记忆化（DP) 划分k个和相等的数组 lc698 从大到小枚举（排序），并且单向枚举（编号递增）。 如果 i &#x3D; i + 1 ，搜索 i 失败则 i + 1 必然失败。 如果 i 为当前第一个元素搜索失败，则无解（如放在桶中的第一个元素）。 如果 i 不位于后面某一组的第一个位置，则前面的一根 j 一定更长。则这种情况一定在之前搜索中已经搜索过了，必然无解，所以 i 必然位于第一个。 如果 i 位于后面一组的第一个位置，则可以交换后一组到当前组，矛盾。 如果 i 为当前最后一个元素搜索失败，则同样无解。 若 i 为最后一个数之后的搜索成功了，则说明存在若干小于 i 的元素放在当前组的末尾（总长与 i 相同），而 i 存在于另一组中，则可以使用 i 与其交换。 123456789101112131415161718192021222324252627282930int[] nums;boolean[] st; //visitint size,len,k; // targetLength, nums.length, k个分段for(int n:nums) sum+=n;if(sum%k!=0) return false; //如果不能整除返回falsesize=sum/k;Arrays.sort(nums); // 优化1： 从大到小枚举（sort递增，反向枚举idx）return dfs(len-1,0,1);boolean dfs(int start, int cur, int cnt)&#123;//起始位置，当前长度，第几根 if (cnt == k) return true; // 不需要递归最后一个，剩余的必然满足 if (cur == size) // 当前子数组满足要求，递归下一个 return dfs(len - 1, 0, cnt + 1); for (int i = start; i &gt;= 0; i--) &#123; if (nums[i] &gt; size) return false;\t//当前第i个比总长size还大，无解，return if (st[i] || nums[i] + cur &gt; size) continue; //已经用过或当前剩余大小不足，枚举下一个 st[i] = true; // backtrack模板,按需记录路径 if (dfs(i - 1, cur + nums[i], cnt)) return true; st[i] = false; if (cur == 0 || cur + nums[i] == size) return false;//优化3,4: 如果当前是第一个或最后一个，无解 while (i &gt; 1 &amp;&amp; nums[i] == nums[i - 1]) i--;//优化2: 跳过所有相同的 &#125; return false;&#125; 数独位运算优化输入输出：每个测试用例占一行，包含 81 个字符，由上到下，同行由左到右 从当前能填合法数字最少的位置开始填数字 任意一个状态下, 只需要找一个位置填数即可, 而不是找所有的位置填数(结果相同) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990int N = 1 &lt;&lt; 9;int[] bitcnt = new int[N]; // 存当前状态下有多少个1(可填数字)int[] bitcheck = new int[N];// 存当前状态(仅一个1)对应的可填数字int[] r;\t// 行状态 =&gt; 还能够选哪些数(1)int[] c;\t// 列状态int[][] g;\t// 方格状态char[] str;\t// 当前状态void solve(String s) &#123; // 初始化bitcnt for (int i = 0; i &lt; N; i++) &#123; for (int j = i; j &gt; 0; j -= lowbit(j)) &#123; bitcnt[i] += 1; &#125; &#125; // 初始化bitcheck for (int i = 0; i &lt; 9; i++) bitcheck[1 &lt;&lt; i] = i; str = s.toCharArray(); r = new int[9]; c = new int[9]; g = new int[3][3]; int cnt = 0;\t//待填数的位置 // 初始化所有 行 列 方格, 状态为 ‘1 1111 1111’ 即全部可选 for (int i = 0; i &lt; 9; i++) &#123; r[i] = c[i] = g[i / 3][i % 3] = N - 1; &#125;\t// 遍历起始状态，填数 for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (str[pos(i, j)] == &#x27;.&#x27;) cnt++; else add(i, j, str[pos(i, j)] - &#x27;1&#x27;); &#125; &#125; dfs(cnt); System.out.println(new String(str));&#125;boolean dfs(int cnt) &#123; if (cnt == 0) return true; // 枚举所有空位,找到可选数字最少的位置[x,y] int min = 10; int x = -1, y = -1; for (int i = 0; i &lt; 9; i++) &#123; for (int j = 0; j &lt; 9; j++) &#123; if (str[getPos(i, j)] == &#x27;.&#x27;) &#123; int st = getNum(i, j); if (bitcnt[st] &lt; min) &#123; x = i; y = j; min = bitcnt[st]; &#125; &#125; &#125; &#125;\t// 枚举所有[x,y]可填的数字num, 使用lowbit配合bitcheck快速判断 for (int i = getNum(x, y); i &gt; 0; i -= lowbit(i)) &#123; int num = bitcheck[lowbit(i)]; add(x, y, num); if (dfs(cnt - 1)) return true; remove(x, y, num); &#125; return false;&#125;// 在位置[x,y]填上num, num取0-8void add(int x, int y, int num) &#123; str[getPos(x, y)] = (char) (&#x27;1&#x27; + num); // 将对应的行列中可选数字消去 r[x] -= 1 &lt;&lt; num; c[y] -= 1 &lt;&lt; num; g[x / 3][y / 3] -= 1 &lt;&lt; num;&#125;// 在位置[x,y] 撤销选择void remove(int x, int y, int num) &#123; str[getPos(x, y)] = &#x27;.&#x27;; r[x] += 1 &lt;&lt; num; c[y] += 1 &lt;&lt; num; g[x / 3][y / 3] += 1 &lt;&lt; num;&#125;// 获得位置[x,y]能够填的数字有哪些, &amp;后为1则为可选int getNum(int x, int y) &#123; return r[x] &amp; c[y] &amp; g[x / 3][y / 3];&#125;// 获得位置[x,y]对应st字符的位置int getPos(int x, int y) &#123; return x * 9 + y;&#125; 蛋糕塔问题使 体积为N，层数为M 的蛋糕塔的表面积最小 1// todo 双向DFS同样将问题分为两半进行搜索，将其中一半的数据进行缓存，在另一半中查表缩小搜索空间。 子集和问题：给定n个正数，从中选则若干个，使其和 不超过w 的 最大和。（n&lt;45, a[i], w &lt; 2^32-1 ) 对于该问题，本质为体积为n的0-1背包问题，但由于体积过大无法枚举，考虑直接枚举物品 选与不选。 由于2^45 依然过大，改为折半搜索，即将数组分为两半，分别枚举前 n&#x2F;2 个数可能构成的和，再枚举 后n&#x2F;2 个数可能构成的和，对前半部分进行查表 更新最大值。空间换时间 搜索顺序：将数组降序排序，先搜索大的部分，将其存入set中 选取划分点：后半部分需要二分查找，每次需要额外$\\mathcal{O}(\\log 2^{\\frac{n}{2}})&#x3D;\\mathcal{O}(n)$的时间，而前半部分仅需要$2^ {\\frac{n}{2}}$，即增加前半部分数量平衡时间 12345678910111213141516171819202122232425262728293031323334353637383940414243TreeSet&lt;Long&gt; set = new TreeSet&lt;&gt;();long res = 0, w;long[] nums;void solve() &#123; w = scan.nextInt(); int n = scan.nextInt(); nums = new long[n]; for (int i = 0; i &lt; n; i++) nums[i] = scan.nextInt(); Arrays.sort(nums); // 从大到小枚举 for (int i = 0, j = n - 1; i &lt; j; i++, j--) &#123; long t = nums[i]; nums[i] = nums[j]; nums[j] = t; &#125; int k=Math.min(n-1,n/2+2); // 偏移搜索终点 dfs1(0, k, 0); dfs2(k, n, 0); System.out.println(res);&#125;void dfs1(int n, int end, long sum) &#123; if (n == end) &#123; set.add(sum);\t// 枚举前半部分，将所有合法值放入TreeSet return; &#125; dfs1(n + 1, end, sum); if (nums[n] + sum &lt;= w) &#123;\t// 可行性剪枝，超过最大值直接返回 dfs1(n + 1, end, sum + nums[n]); &#125;&#125;void dfs2(int n, int end, long sum) &#123; if (n == end) &#123;\t// 后半部，二分搜索取前半部分最大值，加和更新答案 long l = set.floor(w - sum); res = Math.max(res, l + sum); return; &#125; dfs2(n + 1, end, sum); if (sum + nums[n] &lt;= w) &#123; dfs2(n + 1, end, sum + nums[n]); &#125;&#125; Iterative Deepening Search迭代加深：针对 搜索深度深且每层选择很多，但答案深度浅 的问题 每次搜索设置最大深度，超过深度立即返回。虽然在搜索深度为d的过程中会重复搜索d-1的部分，但远小于 深度过大的指数级增长。如果使用bfs，队列大小指数增长，mle。 加成序列: 给定一个整数 n，找出长度为 m 最小的递增序列满足：第一个元素为1，最后一个元素为n，且对于 任意下标 k，存在 0&lt;= i &lt;= j &lt; k 使得 a[k] = a[i] + a[j]。n = 15, 1 2 4 5 10 15 对该问题，可以估算答案为log级别(考虑1,2,4,8,…)，即答案处于搜索树的浅层。使用迭代加深枚举深度搜索。 优化搜索顺序：每次枚举下一个数字时，从大到小枚举，即枚举a[i]+a[j]最大的可能值 排除等效冗余：在枚举 i 和 j 时，当a[i]+a[j]值相等时，搜索结果相同，使用st数组判重 123456789101112131415161718192021222324252627282930boolean dfs(int u, int n, int max, int[] path) &#123;//u当前层数,max限制 if (u == max) return path[u - 1] == n;\t//已经搜到当前限制层数 boolean[] st = new boolean[N];\t//枚举下一个数字的判重数组 for (int i = u - 1; i &gt;= 0; i--) &#123; for (int j = i; j &gt;= 0; j--) &#123; int sum = path[i] + path[j]; //反向枚举最大值 if (sum &gt; n || sum &lt;= path[u - 1] || st[sum]) continue;\t// 当前值合法且未被枚举过 st[sum] = true; path[u] = sum; if (dfs(u + 1, n, max, path)) return true;\t// 递归 &#125; &#125; return false;&#125;void solve() &#123; while (scan.hasNext()) &#123; int n = scan.nextInt(); if (n == 0) break; int[] path = new int[N]; path[0] = 1; int u = 1; while (!dfs(1, n, u, path)) u++;\t//枚举最大深度 for (int i = 0; i &lt; u; i++) &#123; System.out.print(path[i] + &quot; &quot;); &#125; System.out.print(&quot; &quot;); &#125;&#125;"},{"title":"lab3","path":"/wiki/database_lab/lab3/lab3.html","content":"lab3content"},{"title":"lab4","path":"/wiki/database_lab/lab4/lab4.html","content":"lab5content"},{"title":"lab5","path":"/wiki/database_lab/lab5/lab5.html","content":"lab5content"},{"title":"lab6","path":"/wiki/database_lab/lab6/lab6.html","content":"lab6"},{"title":"1 MapReduce","path":"/wiki/distribute_system_lab/lab1/lab1.html","content":"lab1"},{"title":"2A Leader Election","path":"/wiki/distribute_system_lab/lab2/lab2a.html","content":"2a"},{"title":"2C Persistence","path":"/wiki/distribute_system_lab/lab2/lab2c.html","content":"2c"},{"title":"2B Log","path":"/wiki/distribute_system_lab/lab2/lab2b.html","content":"2b"},{"title":"2D Log Compaction","path":"/wiki/distribute_system_lab/lab2/lab2d.html","content":"2d"},{"title":"4A Shard controller","path":"/wiki/distribute_system_lab/lab4/lab4a.html","content":"4a"},{"title":"4B Sharded Key/Value Server","path":"/wiki/distribute_system_lab/lab4/lab4b.html","content":"4b"},{"title":"4C Challenge","path":"/wiki/distribute_system_lab/lab4/lab4c.html","content":"challenge for the lab"},{"title":"3A Key/value service","path":"/wiki/distribute_system_lab/lab3/lab3a.html","content":"3a"},{"title":"3A Snapshot","path":"/wiki/distribute_system_lab/lab3/lab3b.html","content":"3a"},{"title":"angular","path":"/wiki/front_end/angular/angular.html","content":"angular"},{"title":"JS","path":"/wiki/front_end/js/js.html","content":"JS"},{"title":"react","path":"/wiki/front_end/react/react.html","content":"react"},{"title":"vue","path":"/wiki/front_end/vue/vue.html","content":"vue"},{"title":"Java Stream API","path":"/wiki/back-end/language/java/streamAPIs.html","content":"Stream API 也是面试中可能遇到的问题，如果面试官要求使用不熟练非常容易翻车，尤其是在没有IDE提示的白板中。 API直接先看常用的方法，分为 Create, Intermediate, Terminal 三类。 Create12345678910111213Stream.of(1,2,3,4,5);// collectionlist.stream();// arrayArrays.stream(new int[]&#123;1,2,3&#125;);// iteratorStream.iterate(0, n -&gt; n + 2).limit(5);// generatorStream.generate(Math::random).limit(5);// parallel stream// may cause thread safe issue, impl by fork/joinlist.stream().parallel()... Intermediate1234567891011121314151617// filterfilter(user -&gt; user.getId() &gt; 6);// map, map to new objectmap(user -&gt; &quot;user: &quot;+ user.getName());// distinct, hashcode &amp; equals()distinct();// sortedsorted(Comparator.comparing(User::getName));sorted((a,b)-&gt;a-b);// limit, return first n elementslimit(5);// skip, drop first n elementsskip(5);// flatMap, put each element into streamflatMap(user -&gt; Arrays.stream(user.getCity().split(&quot;,&quot;)));// peek, modify each elementpeek(user -&gt; user.setId(user.getId()+1)); Terminal123456789101112131415161718192021// collectcollect(Collectors.toSet());collect(Collectors.toList());Map&lt;String, List&lt;Person&gt;&gt; peopleByCity = personStream.collect(Collectors.groupingBy(Person::getCity));// forEachforEach(System.out::println);// findFirstfindFirst().get();// findAnyfindAny().get();// countcount();// min, max, sum =&gt; getAsInt();// boolean anyMatch, allMatch, nonMatch// reduce, reduce([p1,p2,p3,p4],fn) = reduce([fn(p2,p4),fn(p1,p3)])Optional&lt;String&gt; reduced = collection .stream() .sorted() .reduce((s1, s2) -&gt; s1 + &quot;#&quot; + s2); 典型应用摘自jdk文档，基本覆盖了常见的用法 Accumulate into a List 123List&lt;String&gt; list = people.stream().map(Person::getName)\t.collect(Collectors.toList()); Accumulate names into a TreeSet 123Set&lt;String&gt; set = people.stream() .map(Person::getName) .collect(Collectors.toCollection(TreeSet::new)); Convert elements to strings and concatenate them, separated by commas 123String joined = things.stream() .map(Object::toString) .collect(Collectors.joining(&quot;, &quot;)); Compute sum of salaries of employee 12int total = employees.stream() .collect(Collectors.summingInt(Employee::getSalary)); Group employees by department 12Map&lt;Department, List&lt;Employee&gt;&gt; byDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment)); Compute sum of salaries by department 123Map&lt;Department, Integer&gt; totalByDept = employees.stream() .collect(Collectors.groupingBy(Employee::getDepartment, Collectors.summingInt(Employee::getSalary))); Partition students into passing and failing 12Map&lt;Boolean, List&lt;Student&gt;&gt; passingFailing = students.stream(). collect(Collectors.partitioningBy(s -&gt; s.getGrade() &gt;= PASS_THRESHOLD)); count number 1234int[] nums = new int[]&#123;1, 2, 3, 3, 4, 4, 4, 5, 6&#125;;Map&lt;Integer, Long&gt; collect =Arrays.stream(nums) .boxed()\t// int =&gt; Integer .collect(Collectors.groupingBy(a -&gt; a, Collectors.counting())); mapping 12Map&lt;City, Set&lt;String&gt;&gt; namesByCity = people.stream() .collect(groupingBy(Person::getCity, mapping(Person::getName,toSet()))); flatMapping 12Map&lt;String, Set&lt;LineItem&gt;&gt; itemsByName = orders.stream().collect( groupingBy(Order::getName, flatMapping(order -&gt; order.getItems().stream(), toSet()))); 常见的坑元素的类型 Wrapper classStream API并不会自动进行装箱&#x2F;拆箱操作，有些中间操作对类型有限制，导致报错。 Integer -&gt; int Double -&gt; double Long -&gt; long 举个遇到的具体例子：给定二维String数组scores，每组中包含人名和double分数，求最高的平均分，结果向下取整为int，否则返回0。 12345678String[][] scores = new String[][]&#123; &#123;&quot;alice&quot;, &quot;-1.5&quot;&#125;, &#123;&quot;bob&quot;, &quot;87&quot;&#125;, &#123;&quot;charles&quot;, &quot;100&quot;&#125;, &#123;&quot;charles&quot;, &quot;22&quot;&#125;, &#123;&quot;eric&quot;, &quot;64&quot;&#125;&#125;;// output: 87 思路也很简单直接是 Compute sum of salaries by department 的加强版，先贴上答案： 12345int res = (int) Math.floor(Arrays.stream(scores). collect(Collectors.groupingBy(a -&gt; a[0], Collectors.averagingDouble(a -&gt; Double.parseDouble(a[1])))) .values().stream() .mapToDouble(Double::doubleValue) .max().orElse(0)); 当时写的时候没有mapToDouble就报错，也没搞懂怎么回事。换到IDE里会提示 12.values().stream() // Stream&lt;Double&gt;.mapToDouble(Double::doubleValue) // DoubleStream 对于这两个的区别，贴上gpt给出的解释 Stream&lt;Double&gt;: Stream&lt;Double&gt; is a stream of boxed Double objects. This means that each double value is wrapped in a Double object to be used within the stream context. DoubleStream is a specialized stream designed to work directly with primitive double values without boxing&#x2F;unboxing overhead. 原因就很明了了，再看下对于两种特有的操作，依旧gpt Stream&lt;Double&gt;: It provides a wide range of operations defined in the Stream API, such as map, filter, reduce, and more. These operations are designed to work with objects and are less efficient for primitive types due to the boxing and unboxing overhead. DoubleStream: It offers operations specifically optimized for primitive double values, which makes it more efficient for numerical computations. Common operations in a DoubleStream include mapToDouble, filter, sum, average, and others. You might use DoubleStream when your primary concern is numerical computations and you want to avoid the overhead of boxing double values into Double objects. 1234List&lt;Double&gt; ls = new ArrayList&lt;&gt;(Arrays.asList(1.0, 2.0, 3.0));double c = ls.stream() .mapToDouble(Double::doubleValue) .sum();1234List&lt;Double&gt; ls = new ArrayList&lt;&gt;(Arrays.asList(1.0, 2.0, 3.0));double c = ls.stream() .sum(); // exception// sum() 只能处理primitive 解决方法 primitive-&gt;box: boxed() box-&gt;primitive: mapToInt()/mapToLong()/mapToDouble()"},{"title":"Binary Lifting","path":"/wiki/algorithm/basicAlgo/binary_lifting.html","content":"树上倍增，常用于求 LCA 问题 对于一棵树，预处理每个节点的第 $2^i$ 父节点，加快上跳预处理 $ n \\log n$，单次查询 $ \\log n$ 给定n个点，n-1条边，dfs建树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990int n;int[][] edges;int[] st, end, ne, w;// n 的二进制位数，最多单次上跳2^m次int m = 32 - Integer.numberOfLeadingZeros(n);// parent数组, d[i][j] 为第i个节点上跳2^j次的节点int[][] pa = new int[n][m];// d记录节点深度int[] d = new int[n];// 邻接表Arrays.fill(st, -1);for(int e:edges)&#123; // 无向图 ...&#125;// dfs建树, 0号节点为根，对应父节点-1pa[0][0] = -1;dfs(0,-1);void dfs(int cur, int fa)&#123; pa[cur][0]=fa; // 遍历当前点所有临边 for(int i=st[cur];i!=-1;i=ne[i])&#123; int x=end[i]; // 终止点不为父节点，单向向下 if(x!=fa)&#123; // 更新深度 d[x]=d[fa]+1; // 递归处理 dsf(x,cur); &#125; &#125;&#125;// 枚举层数i计算// pa[x][i+1] = pa[pa[x][i]][i]for(int i=0;i&lt;m-1;i++)&#123; // 枚举当前点x for(int x=0;x&lt;n;x++)&#123; // 当前点x的上跳2^i次的父节点p int p = pa[x][i]; // 如过已经超过根节点，则为-1 if(p==-1) pa[x][i+1]=-1; else pa[x][i+1]=pa[p][i]; // 可以同时维护上跳过程中 路径信息 &#125;&#125;// 求某个节点上跳k次后的节点, 对应k的二进制bitint get(int cur, int k)&#123; for(int i=0;i&lt;32&amp;&amp;x!=-1;i++)&#123; if(((k&gt;&gt;i)&amp;1)==1) cur=f[cur][i]; &#125; return cur; // 或者 for(;k&gt;0&amp;&amp;cur!=-1;k&amp;=k-1) cur=pa[cur][Integer.numberOfTrailingZeros(k)]; return cur;&#125;// LCAint lca(int x,int y)&#123; // step 1: 将两节点调节至相同深度 if(d[x]&gt;d[y])&#123; int t=x; x=y; y=t; &#125; // y需要上跳 d[y]-d[x] y=get(y,d[y]-d[x]); // step2: 从大到小枚举，如果未重叠则上跳 if(x==y) return x; for(int i=m-1;i&gt;=0;i--)&#123; int px=pa[x][i],py=pa[y][i]; if(px!=py)&#123; x=px; y=py; &#125; &#125; // 最后x的父节点为LCA return pa[x][0];&#125;"}]